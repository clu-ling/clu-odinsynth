<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>odinson.ruleutils.queryast API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>odinson.ruleutils.queryast</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations
import json
import math
import itertools
from typing import List, Text, Optional, Tuple, Type, Union
from odinson.ruleutils import config

__all__ = [
    &#34;Vocabularies&#34;,
    &#34;AstNode&#34;,
    &#34;Matcher&#34;,
    &#34;HoleMatcher&#34;,
    &#34;ExactMatcher&#34;,
    &#34;Constraint&#34;,
    &#34;HoleConstraint&#34;,
    &#34;WildcardConstraint&#34;,
    &#34;FieldConstraint&#34;,
    &#34;NotConstraint&#34;,
    &#34;AndConstraint&#34;,
    &#34;OrConstraint&#34;,
    &#34;Surface&#34;,
    &#34;HoleSurface&#34;,
    &#34;TokenSurface&#34;,
    &#34;MentionSurface&#34;,
    &#34;WildcardSurface&#34;,
    &#34;ConcatSurface&#34;,
    &#34;OrSurface&#34;,
    &#34;RepeatSurface&#34;,
    &#34;Traversal&#34;,
    &#34;HoleTraversal&#34;,
    &#34;IncomingWildcardTraversal&#34;,
    &#34;OutgoingWildcardTraversal&#34;,
    &#34;RepeatTraversal&#34;,
    &#34;Query&#34;,
    &#34;HoleQuery&#34;,
    &#34;HybridQuery&#34;,
    &#34;IncomingLabelTraversal&#34;,
    &#34;OutgoingLabelTraversal&#34;,
    &#34;ConcatTraversal&#34;,
    &#34;OrTraversal&#34;,
    &#34;RepeatTraversal&#34;,
    &#34;Query&#34;,
    &#34;HoleQuery&#34;,
    &#34;HybridQuery&#34;,
]


# type alias
Vocabularies = config.Vocabularies


OPERATORS_TO_EXCLUDE = {&#34;]&#34;, &#34;)&#34;, &#34;}&#34;}


OPERATORS = {
    &#34;[&#34;,
    &#34;(&#34;,
    &#34;{&#34;,
    &#34;?&#34;,
    &#34;*&#34;,
    &#34;+&#34;,
    &#34;=&#34;,
    &#34;!&#34;,
    &#34;&amp;&#34;,
    &#34;|&#34;,
    &#34;,&#34;,
    &#34;@&#34;,
    &#34;&lt;&#34;,
    &#34;&gt;&#34;,
    &#34;&gt;&gt;&#34;,
    &#34;&lt;&lt;&#34;,
}


class CognitiveWeight:
    FIELD_CONSTRAINT = 1
    NOT_CONSTRAINT = 2
    AND_CONSTRAINT = 3
    OR_CONSTRAINT = 4
    WILDCARD_SURFACE = 1
    TOKEN_SURFACE = 1
    MENTION_SURFACE = 1
    CONCAT_SURFACE = 3
    OR_SURFACE = 4
    REPEAT_SURFACE = 5
    INCOMING_WILDCARD_TRAVERSAL = 1
    OUTGOING_WILDCARD_TRAVERSAL = 1
    INCOMING_LABEL_TRAVERSAL = 1
    OUTGOING_LABEL_TRAVERSAL = 1
    CONCAT_TRAVERSAL = 3
    OR_TRAVERSAL = 4
    REPEAT_TRAVERSAL = 5
    HYBRID_QUERY = 2


class AstNode:
    &#34;&#34;&#34;The base class for all AST nodes.&#34;&#34;&#34;

    def __repr__(self):
        return f&#34;&lt;{self.__class__.__name__}: {str(self)!r}&gt;&#34;

    def __eq__(self, value):
        return self.id_tuple() == value.id_tuple()

    def __hash__(self):
        return hash(self.id_tuple())

    def children(self):
        return []

    def id_tuple(self):
        return (type(self), *self.children())

    def is_hole(self) -&gt; bool:
        &#34;&#34;&#34;Returns true if the node is a hole.&#34;&#34;&#34;
        # most nodes are not holes,
        # so only the Hole* nodes need to override this
        return False

    def has_holes(self) -&gt; bool:
        &#34;&#34;&#34;Returns true if the pattern has one or more holes.&#34;&#34;&#34;
        # most nodes need to override this to handle their children,
        # so the default implementation is intended for Hole* nodes
        return self.is_hole() or any(c.has_holes() for c in self.children())

    def is_valid(self) -&gt; bool:
        &#34;&#34;&#34;Returns true if the pattern is valid, i.e., has no holes.&#34;&#34;&#34;
        return not self.has_holes()

    def tokens(self) -&gt; List[Text]:
        &#34;&#34;&#34;Returns the pattern as a list of tokens.&#34;&#34;&#34;
        # default implementation is intended for nodes that have no children
        return [Text(self)]

    def num_matcher_holes(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of matcher holes in this pattern.&#34;&#34;&#34;
        return sum(c.num_matcher_holes() for c in self.children())

    def num_constraint_holes(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of constraint holes in this pattern.&#34;&#34;&#34;
        return sum(c.num_constraint_holes() for c in self.children())

    def num_surface_holes(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of surface holes in this pattern.&#34;&#34;&#34;
        return sum(c.num_surface_holes() for c in self.children())

    def num_traversal_holes(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of traversal holes in this pattern.&#34;&#34;&#34;
        return sum(c.num_traversal_holes() for c in self.children())

    def num_query_holes(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of traversal holes in this pattern.&#34;&#34;&#34;
        return sum(c.num_query_holes() for c in self.children())

    def num_holes(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of holes in this pattern.&#34;&#34;&#34;
        return (
            self.num_matcher_holes()
            + self.num_constraint_holes()
            + self.num_surface_holes()
            + self.num_traversal_holes()
            + self.num_query_holes()
        )

    def expand_leftmost_hole(
        self, vocabularies: Vocabularies, **kwargs
    ) -&gt; List[AstNode]:
        &#34;&#34;&#34;
        If the pattern has holes then it returns the patterns obtained
        by expanding the leftmost hole.  If there are no holes then it
        returns an empty list.
        &#34;&#34;&#34;
        # default implementation is suitable for Matchers only
        return []

    def preorder_traversal(self) -&gt; List[AstNode]:
        &#34;&#34;&#34;Returns a list with all the nodes of the tree in preorder.&#34;&#34;&#34;
        # default implementation is for nodes that have no children
        return [self] + [c.preorder_traversal() for c in self.children()]

    def permutations(self) -&gt; List[AstNode]:
        &#34;&#34;&#34;Returns all trees that are equivalent to this AstNode.&#34;&#34;&#34;
        return [self]

    def over_approximation(self) -&gt; Optional[AstNode]:
        &#34;&#34;&#34;Returns a rule with a language that contains all the languages
        of the current node&#39;s descendents.&#34;&#34;&#34;
        return self

    def under_approximation(self) -&gt; Optional[AstNode]:
        &#34;&#34;&#34;Returns a rule with a language that is subsumed by the languages
        of all the descendents of the current node&#34;&#34;&#34;
        return self

    def redundancy_patterns(self) -&gt; List[AstNode]:
        return [n.over_approximation() for n in set(self.unroll().split())]

    def unroll(self) -&gt; AstNode:
        &#34;&#34;&#34;unroll repetitions&#34;&#34;&#34;
        return self

    def split(self) -&gt; List[AstNode]:
        &#34;&#34;&#34;decompose rule&#34;&#34;&#34;
        return [self]

    _COGNITIVE_WEIGHT = 0

    def cognitive_weight(self) -&gt; int:
        return self._COGNITIVE_WEIGHT + sum(
            c.cognitive_weight() for c in self.children()
        )

    def operators(self) -&gt; list[str]:
        return [t for t in self.tokens() if t in OPERATORS]

    def operands(self) -&gt; list[str]:
        return [
            t
            for t in self.tokens()
            if t not in OPERATORS and t not in OPERATORS_TO_EXCLUDE
        ]

    def num_operators(self) -&gt; int:
        return len(self.operators())

    def num_distinct_operators(self) -&gt; int:
        return len(set(self.operators()))

    def num_operands(self) -&gt; int:
        return len(self.operands())

    def num_distinct_operands(self) -&gt; int:
        return len(set(self.operands()))

    def implementation_length(self) -&gt; int:
        return self.num_operators() + self.num_operands()

    def vocabulary_length(self) -&gt; int:
        return self.num_distinct_operators() + self.num_distinct_operands()

    def program_length(self) -&gt; float:
        operators = self.num_distinct_operators()
        operands = self.num_distinct_operands()
        return operators * math.log(operators, 2) + operands * math.log(operands, 2)

    def program_volume(self) -&gt; float:
        return self.implementation_length() * math.log(self.vocabulary_length(), 2)

    def potential_volume(self) -&gt; float:
        # NOTE this may not be correct for our language
        x = 2 + self.num_distinct_operands()
        return x * math.log(x, 2)

    def program_level(self) -&gt; float:
        return self.potential_volume() / self.program_volume()

    def effort(self) -&gt; float:
        return self.program_volume() / self.program_level()

    def number_incomings(self) -&gt; int:
        return len([t for t in self.tokens() if t.startswith(&#34;&lt;&#34;)])

    def number_outgoings(self) -&gt; int:
        return len([t for t in self.tokens() if t.startswith(&#34;&gt;&#34;)])

    def proportion_incoming(self) -&gt; float:
        n_in = self.number_incomings()
        n_out = self.number_outgoings()
        return n_in / (n_in + n_out)

    def num_quantifiers(self):
        return sum(c.num_quantifiers() for c in self.children())

    def num_nodes(self) -&gt; int:
        return 1 + sum(c.num_nodes() for c in self.children())

    def num_leaves(self) -&gt; int:
        children = self.children()
        return 1 if not children else sum(c.num_leaves() for c in children)

    def tree_height(self, func):
        height = 0
        children = self.children()
        if children:
            height = func(c.tree_height(func) for c in children)
        return height + 1

    def max_tree_height(self) -&gt; int:
        return self.tree_height(max)

    def min_tree_height(self) -&gt; int:
        return self.tree_height(min)


# type alias
Types = Type[Union[AstNode, Tuple[AstNode]]]


def is_identifier(s: Text) -&gt; bool:
    &#34;&#34;&#34;returns true if the provided string is a valid identifier&#34;&#34;&#34;
    return config.IDENT_RE.match(s) is not None


def maybe_parens(node: AstNode, types: Types) -&gt; str:
    &#34;&#34;&#34;Converts node to string. Surrounds by parenthesis
    if node is subclass of provided types.&#34;&#34;&#34;
    return f&#34;({node})&#34; if isinstance(node, types) else str(node)


def maybe_parens_tokens(node: AstNode, types: Types) -&gt; List[Text]:
    &#34;&#34;&#34;Converts node to list of tokens. Surrounds by parenthesis
    if node is subclass of provided types.&#34;&#34;&#34;
    return [&#34;(&#34;, *node.tokens(), &#34;)&#34;] if isinstance(node, types) else node.tokens()


def make_quantifier(min: int, max: Optional[int]) -&gt; str:
    &#34;&#34;&#34;Gets the desired minimum and maximum repetitions
    and returns the appropriate quantifier.&#34;&#34;&#34;
    return &#34;&#34;.join(make_quantifier_tokens(min, max))


def make_quantifier_tokens(min: int, max: Optional[int]) -&gt; List[Text]:
    &#34;&#34;&#34;Gets the desired minimum and maximum repetitions
    and returns the sequence of tokens corresponding
    to the appropriate quantifier.&#34;&#34;&#34;
    if min == max:
        return [&#34;{&#34;, str(min), &#34;}&#34;]
    if max == None:
        if min == 0:
            return [&#34;*&#34;]
        elif min == 1:
            return [&#34;+&#34;]
        else:
            return [&#34;{&#34;, str(min), &#34;,&#34;, &#34;}&#34;]
    if min == 0:
        if max == 1:
            return [&#34;?&#34;]
        else:
            return [&#34;{&#34;, &#34;,&#34;, str(max), &#34;}&#34;]
    return [&#34;{&#34;, str(min), &#34;,&#34;, str(max), &#34;}&#34;]


def all_binary_trees(nodes: List[AstNode], cls: Type) -&gt; List[AstNode]:
    &#34;&#34;&#34;Returns all the binary trees of type `cls` that can be constructed
    with the given nodes.&#34;&#34;&#34;
    if len(nodes) == 1:
        return nodes
    trees = []
    for i in range(1, len(nodes)):
        for l in all_binary_trees(nodes[:i], cls):
            for r in all_binary_trees(nodes[i:], cls):
                trees.append(cls(l, r))
    return trees


def get_clauses(node, cls=None):
    &#34;&#34;&#34;Flattens and returns the clauses of the given node.&#34;&#34;&#34;
    clauses = []
    if cls is None:
        cls = type(node)
    if isinstance(node.lhs, cls):
        clauses += get_clauses(node.lhs, cls)
    else:
        clauses.append(node.lhs)
    if isinstance(node.rhs, cls):
        clauses += get_clauses(node.rhs, cls)
    else:
        clauses.append(node.rhs)
    return clauses


def get_all_trees(node: AstNode) -&gt; List[AstNode]:
    &#34;&#34;&#34;Returns all equivalent trees to node.&#34;&#34;&#34;
    results = []
    cls = type(node)
    perms_per_clause = [c.permutations() for c in get_clauses(node)]
    for clauses in itertools.product(*perms_per_clause):
        results += all_binary_trees(clauses, cls)
    return results


####################
# string matchers
####################


class Matcher(AstNode):
    &#34;&#34;&#34;The base class for all string matchers.&#34;&#34;&#34;


class HoleMatcher(Matcher):
    def __str__(self):
        return config.SURFACE_HOLE_GLYPH

    def is_hole(self):
        return True

    def num_matcher_holes(self):
        return 1

    def over_approximation(self):
        return WildcardMatcher()

    def under_approximation(self):
        return None


class WildcardMatcher(Matcher):
    def __str__(self):
        # this should never be rendered
        return &#34;???&#34;


class ExactMatcher(Matcher):
    def __init__(self, s: Text):
        self.string = s

    def __str__(self):
        if is_identifier(self.string):
            # don&#39;t surround identifiers with quotes
            return self.string
        else:
            return json.dumps(self.string)

    def id_tuple(self):
        return super().id_tuple() + (self.string,)


####################
# token constraints
####################


class Constraint(AstNode):
    &#34;&#34;&#34;The base class for all token constraints.&#34;&#34;&#34;


class WildcardConstraint(Constraint):
    def __str__(self):
        # this should never be rendered
        return &#34;???&#34;


class HoleConstraint(Constraint):
    def __str__(self):
        return config.SURFACE_HOLE_GLYPH

    def is_hole(self):
        return True

    def num_constraint_holes(self):
        return 1

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        return [
            FieldConstraint(HoleMatcher(), HoleMatcher()),
            NotConstraint(HoleConstraint()),
            AndConstraint(HoleConstraint(), HoleConstraint()),
            OrConstraint(HoleConstraint(), HoleConstraint()),
        ]

    def over_approximation(self):
        return WildcardConstraint()

    def under_approximation(self):
        return None


class FieldConstraint(Constraint):
    _COGNITIVE_WEIGHT = CognitiveWeight.FIELD_CONSTRAINT

    def __init__(self, name: Matcher, value: Matcher):
        self.name = name
        self.value = value

    def __str__(self):
        return f&#34;{self.name}={self.value}&#34;

    def children(self):
        return [self.name, self.value]

    def tokens(self):
        return self.name.tokens() + [&#34;=&#34;] + self.value.tokens()

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        if self.name.is_hole():
            return [
                FieldConstraint(ExactMatcher(name), self.value)
                for name in vocabularies
                if name not in config.EXCLUDE_FIELDS
            ]
        elif self.value.is_hole():
            return [
                FieldConstraint(self.name, ExactMatcher(value))
                for value in vocabularies[self.name.string]
            ]
        else:
            return []

    def over_approximation(self):
        name = self.name.over_approximation()
        if name is None:
            return None
        if isinstance(name, WildcardMatcher):
            return WildcardConstraint()
        value = self.value.over_approximation()
        if value is None:
            return None
        if isinstance(value, WildcardMatcher):
            return WildcardConstraint()
        return FieldConstraint(name, value)

    def under_approximation(self):
        name = self.name.under_approximation()
        if name is None:
            return None
        if isinstance(name, WildcardMatcher):
            return WildcardConstraint()
        value = self.value.under_approximation()
        if value is None:
            return None
        if isinstance(value, WildcardMatcher):
            return WildcardConstraint()
        return FieldConstraint(name, value)


class NotConstraint(Constraint):
    _COGNITIVE_WEIGHT = CognitiveWeight.NOT_CONSTRAINT

    def __init__(self, c: Constraint):
        self.constraint = c

    def __str__(self):
        c = maybe_parens(self.constraint, (AndConstraint, OrConstraint))
        return f&#34;!{c}&#34;

    def children(self):
        return [self.constraint]

    def tokens(self):
        return [&#34;!&#34;] + maybe_parens_tokens(
            self.constraint, (AndConstraint, OrConstraint)
        )

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        # get the next nodes for the nested constraint
        nodes = self.constraint.expand_leftmost_hole(vocabularies, **kwargs)
        # avoid nesting negations
        return [NotConstraint(n) for n in nodes if not isinstance(n, NotConstraint)]

    def permutations(self):
        return [NotConstraint(p) for p in self.constraint.permutations()]

    def over_approximation(self):
        constraint = self.constraint.over_approximation()
        if constraint is None:
            return WildcardConstraint()
        if isinstance(constraint, WildcardConstraint):
            return None
        return NotConstraint(constraint)

    def under_approximation(self):
        constraint = self.constraint.under_approximation()
        if constraint is None:
            return WildcardConstraint()
        if isinstance(constraint, WildcardConstraint):
            return None
        return NotConstraint(constraint)


class AndConstraint(Constraint):
    _COGNITIVE_WEIGHT = CognitiveWeight.AND_CONSTRAINT

    def __init__(self, lhs: Constraint, rhs: Constraint):
        self.lhs = lhs
        self.rhs = rhs

    def __str__(self):
        return f&#34;{self.lhs} &amp; {self.rhs}&#34;

    def children(self):
        return [self.lhs, self.rhs]

    def tokens(self):
        tokens = []
        tokens += maybe_parens_tokens(self.lhs, OrConstraint)
        tokens.append(&#34;&amp;&#34;)
        tokens += maybe_parens_tokens(self.rhs, OrConstraint)
        return tokens

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        if self.lhs.has_holes():
            nodes = self.lhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [AndConstraint(n, self.rhs) for n in nodes]
        elif self.rhs.has_holes():
            nodes = self.rhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [AndConstraint(self.lhs, n) for n in nodes]
        else:
            return []

    def permutations(self):
        return get_all_trees(self)

    def over_approximation(self):
        lhs = self.lhs.over_approximation()
        rhs = self.rhs.over_approximation()
        if lhs is None or rhs is None:
            return None
        if isinstance(lhs, WildcardConstraint):
            return rhs
        if isinstance(rhs, WildcardConstraint):
            return lhs
        return AndConstraint(lhs, rhs)

    def under_approximation(self):
        lhs = self.lhs.under_approximation()
        rhs = self.rhs.under_approximation()
        if lhs is None or rhs is None:
            return None
        if isinstance(lhs, WildcardConstraint):
            return rhs
        if isinstance(rhs, WildcardConstraint):
            return lhs
        return AndConstraint(lhs, rhs)


class OrConstraint(Constraint):
    _COGNITIVE_WEIGHT = CognitiveWeight.OR_CONSTRAINT

    def __init__(self, lhs: Constraint, rhs: Constraint):
        self.lhs = lhs
        self.rhs = rhs

    def __str__(self):
        return f&#34;{self.lhs} | {self.rhs}&#34;

    def children(self):
        return [self.lhs, self.rhs]

    def tokens(self):
        return [*self.lhs.tokens(), &#34;|&#34;, *self.rhs.tokens()]

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        if self.lhs.has_holes():
            nodes = self.lhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [OrConstraint(n, self.rhs) for n in nodes]
        elif self.rhs.has_holes():
            nodes = self.rhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [OrConstraint(self.lhs, n) for n in nodes]
        else:
            return []

    def permutations(self):
        return get_all_trees(self)

    def over_approximation(self):
        lhs = self.lhs.over_approximation()
        rhs = self.rhs.over_approximation()
        if lhs is None:
            return rhs
        if rhs is None:
            return lhs
        if isinstance(lhs, WildcardConstraint) or isinstance(rhs, WildcardConstraint):
            return WildcardConstraint()
        return OrConstraint(lhs, rhs)

    def under_approximation(self):
        lhs = self.lhs.under_approximation()
        rhs = self.rhs.under_approximation()
        if lhs is None:
            return rhs
        if rhs is None:
            return lhs
        if isinstance(lhs, WildcardConstraint) or isinstance(rhs, WildcardConstraint):
            return WildcardConstraint()
        return OrConstraint(lhs, rhs)

    def split(self):
        return self.lhs.split() + self.rhs.split()


####################
# surface patterns
####################


class Surface(AstNode):
    &#34;&#34;&#34;The base class for all surface patterns.&#34;&#34;&#34;


class HoleSurface(Surface):
    def __str__(self):
        return config.SURFACE_HOLE_GLYPH

    def is_hole(self):
        return True

    def num_surface_holes(self):
        return 1

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        candidates = [
            TokenSurface(HoleConstraint()),
        ]
        if kwargs.get(&#34;allow_surface_wildcards&#34;, True):
            candidates.append(WildcardSurface())
        if (
            kwargs.get(&#34;allow_surface_mentions&#34;, True)
            and config.ENTITY_FIELD in vocabularies
        ):
            candidates.append(MentionSurface(HoleMatcher()))
        if kwargs.get(&#34;allow_surface_alternations&#34;, True):
            candidates.append(OrSurface(HoleSurface(), HoleSurface()))
        if kwargs.get(&#34;allow_surface_concatenations&#34;, True):
            candidates.append(ConcatSurface(HoleSurface(), HoleSurface()))
        if kwargs.get(&#34;allow_surface_repetitions&#34;, True):
            candidates += [
                RepeatSurface(HoleSurface(), 0, 1),
                RepeatSurface(HoleSurface(), 0, None),
                RepeatSurface(HoleSurface(), 1, None),
            ]
        return candidates

    def over_approximation(self):
        return RepeatSurface(WildcardSurface(), 0, None)

    def under_approximation(self):
        return None


class WildcardSurface(Surface):
    _COGNITIVE_WEIGHT = CognitiveWeight.WILDCARD_SURFACE

    def __str__(self):
        return &#34;[]&#34;

    def tokens(self):
        return [&#34;[&#34;, &#34;]&#34;]


class TokenSurface(Surface):
    _COGNITIVE_WEIGHT = CognitiveWeight.TOKEN_SURFACE

    def __init__(self, c: Constraint):
        self.constraint = c

    def __str__(self):
        return f&#34;[{self.constraint}]&#34;

    def children(self):
        return [self.constraint]

    def tokens(self):
        return [&#34;[&#34;, *self.constraint.tokens(), &#34;]&#34;]

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        nodes = self.constraint.expand_leftmost_hole(vocabularies, **kwargs)
        return [TokenSurface(n) for n in nodes]

    def permutations(self):
        return [TokenSurface(p) for p in self.constraint.permutations()]

    def over_approximation(self):
        constraint = self.constraint.over_approximation()
        if constraint is None:
            return None
        if isinstance(constraint, WildcardConstraint):
            return WildcardSurface()
        return TokenSurface(constraint)

    def under_approximation(self):
        constraint = self.constraint.under_approximation()
        if constraint is None:
            return None
        if isinstance(constraint, WildcardConstraint):
            return WildcardSurface()
        return TokenSurface(constraint)

    def unroll(self):
        return TokenSurface(self.constraint.unroll())

    def split(self):
        return [TokenSurface(c) for c in self.constraint.split()]


class MentionSurface(Surface):
    _COGNITIVE_WEIGHT = CognitiveWeight.MENTION_SURFACE

    def __init__(self, label: Matcher):
        self.label = label

    def __str__(self):
        return f&#34;@{self.label}&#34;

    def children(self):
        return [self.label]

    def tokens(self):
        return [&#34;@&#34;] + self.label.tokens()

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        entities = vocabularies.get(config.ENTITY_FIELD, [])
        return [MentionSurface(ExactMatcher(e)) for e in entities]


class ConcatSurface(Surface):
    _COGNITIVE_WEIGHT = CognitiveWeight.CONCAT_SURFACE

    def __init__(self, lhs: Surface, rhs: Surface):
        self.lhs = lhs
        self.rhs = rhs

    def __str__(self):
        lhs = maybe_parens(self.lhs, OrSurface)
        rhs = maybe_parens(self.rhs, OrSurface)
        return f&#34;{lhs} {rhs}&#34;

    def children(self):
        return [self.lhs, self.rhs]

    def tokens(self):
        tokens = []
        tokens += maybe_parens_tokens(self.lhs, OrSurface)
        tokens += maybe_parens_tokens(self.rhs, OrSurface)
        return tokens

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        if self.lhs.has_holes():
            nodes = self.lhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [ConcatSurface(n, self.rhs) for n in nodes]
        elif self.rhs.has_holes():
            nodes = self.rhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [ConcatSurface(self.lhs, n) for n in nodes]
        else:
            return []

    def permutations(self):
        return get_all_trees(self)

    def over_approximation(self):
        lhs = self.lhs.over_approximation()
        if lhs is None:
            return None
        rhs = self.rhs.over_approximation()
        if rhs is None:
            return None
        return ConcatSurface(lhs, rhs)

    def under_approximation(self):
        lhs = self.lhs.under_approximation()
        if lhs is None:
            return None
        rhs = self.rhs.under_approximation()
        if rhs is None:
            return None
        return ConcatSurface(lhs, rhs)

    def unroll(self):
        return ConcatSurface(self.lhs.unroll(), self.rhs.unroll())

    def split(self):
        results = []
        for lhs in self.lhs.split():
            results.append(ConcatSurface(lhs, self.rhs))
        for rhs in self.rhs.split():
            results.append(ConcatSurface(self.lhs, rhs))
        return results


class OrSurface(Surface):
    _COGNITIVE_WEIGHT = CognitiveWeight.OR_SURFACE

    def __init__(self, lhs: Surface, rhs: Surface):
        self.lhs = lhs
        self.rhs = rhs

    def __str__(self):
        return f&#34;{self.lhs} | {self.rhs}&#34;

    def children(self):
        return [self.lhs, self.rhs]

    def tokens(self):
        return [*self.lhs.tokens(), &#34;|&#34;, *self.rhs.tokens()]

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        if self.lhs.has_holes():
            nodes = self.lhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [OrSurface(n, self.rhs) for n in nodes]
        elif self.rhs.has_holes():
            nodes = self.rhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [OrSurface(self.lhs, n) for n in nodes]
        else:
            return []

    def permutations(self):
        return get_all_trees(self)

    def over_approximation(self):
        lhs = self.lhs.over_approximation()
        rhs = self.rhs.over_approximation()
        if lhs is None:
            return rhs
        if rhs is None:
            return lhs
        return OrSurface(lhs, rhs)

    def under_approximation(self):
        lhs = self.lhs.under_approximation()
        rhs = self.rhs.under_approximation()
        if lhs is None:
            return rhs
        if rhs is None:
            return lhs
        return OrSurface(lhs, rhs)

    def unroll(self):
        return OrSurface(self.lhs.unroll(), self.rhs.unroll())

    def split(self):
        return self.lhs.split() + self.rhs.split()


class RepeatSurface(Surface):
    _COGNITIVE_WEIGHT = CognitiveWeight.REPEAT_SURFACE

    def __init__(self, surf: Surface, min: int, max: Optional[int]):
        self.surf = surf
        self.min = min
        self.max = max

    def __str__(self):
        surf = maybe_parens(self.surf, (ConcatSurface, OrSurface))
        quant = make_quantifier(self.min, self.max)
        return f&#34;{surf}{quant}&#34;

    def children(self):
        return [self.surf]

    def id_tuple(self):
        return super().id_tuple() + (self.min, self.max)

    def tokens(self):
        tokens = []
        tokens += maybe_parens_tokens(self.surf, (ConcatSurface, OrSurface))
        tokens += make_quantifier_tokens(self.min, self.max)
        return tokens

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        nodes = self.surf.expand_leftmost_hole(vocabularies, **kwargs)
        # avoid nesting repetitions
        nodes = [n for n in nodes if not isinstance(n, RepeatSurface)]
        return [RepeatSurface(n, self.min, self.max) for n in nodes]

    def permutations(self):
        return [RepeatSurface(p, self.min, self.max) for p in self.surf.permutations()]

    def over_approximation(self):
        surf = self.surf.over_approximation()
        if surf is None:
            return None
        return RepeatSurface(surf, self.min, self.max)

    def under_approximation(self):
        surf = self.surf.under_approximation()
        if surf is None:
            return None
        return RepeatSurface(surf, self.min, self.max)

    def unroll(self):
        if self.min &lt;= 1 and self.max is None:
            return ConcatSurface(self.surf, ConcatSurface(self.surf, self))
        return self

    def num_quantifiers(self):
        return 1 + self.surf.num_quantifiers()


####################
# traversal patterns
####################


class Traversal(AstNode):
    &#34;&#34;&#34;The base class for all graph traversals.&#34;&#34;&#34;


class HoleTraversal(Traversal):
    def __str__(self):
        return config.TRAVERSAL_HOLE_GLYPH

    def is_hole(self):
        return True

    def num_traversal_holes(self):
        return 1

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        candidates = [
            IncomingLabelTraversal(HoleMatcher()),
            OutgoingLabelTraversal(HoleMatcher()),
        ]
        if kwargs.get(&#34;allow_traversal_wildcards&#34;, True):
            candidates += [
                IncomingWildcardTraversal(),
                OutgoingWildcardTraversal(),
            ]
        if kwargs.get(&#34;allow_traversal_alternations&#34;, True):
            candidates.append(OrTraversal(HoleTraversal(), HoleTraversal()))
        if kwargs.get(&#34;allow_traversal_concatenations&#34;, True):
            candidates.append(ConcatTraversal(HoleTraversal(), HoleTraversal()))
        if kwargs.get(&#34;allow_traversal_repetitions&#34;, True):
            candidates += [
                RepeatTraversal(HoleTraversal(), 0, 1),
                RepeatTraversal(HoleTraversal(), 0, None),
                RepeatTraversal(HoleTraversal(), 1, None),
            ]
        return candidates

    def over_approximation(self):
        return RepeatTraversal(
            OrTraversal(IncomingWildcardTraversal(), OutgoingWildcardTraversal()),
            0,
            None,
        )

    def under_approximation(self):
        return None


class IncomingWildcardTraversal(Traversal):
    _COGNITIVE_WEIGHT = CognitiveWeight.INCOMING_WILDCARD_TRAVERSAL

    def __str__(self):
        return &#34;&lt;&lt;&#34;


class OutgoingWildcardTraversal(Traversal):
    _COGNITIVE_WEIGHT = CognitiveWeight.OUTGOING_WILDCARD_TRAVERSAL

    def __str__(self):
        return &#34;&gt;&gt;&#34;


class IncomingLabelTraversal(Traversal):
    _COGNITIVE_WEIGHT = CognitiveWeight.INCOMING_LABEL_TRAVERSAL

    def __init__(self, label: Matcher):
        self.label = label

    def __str__(self):
        return f&#34;&lt;{self.label}&#34;

    def children(self):
        return [self.label]

    def tokens(self):
        return [&#34;&lt;&#34;] + self.label.tokens()

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        if self.label.is_hole():
            return [
                IncomingLabelTraversal(ExactMatcher(v))
                for v in vocabularies.get(config.SYNTAX_FIELD, [])
            ]
        else:
            return []

    def over_approximation(self):
        label = self.label.over_approximation()
        if label is None:
            return None
        if isinstance(label, WildcardMatcher):
            return IncomingWildcardTraversal()
        return IncomingLabelTraversal(label)

    def under_approximation(self):
        label = self.label.under_approximation()
        if label is None:
            return None
        if isinstance(label, WildcardMatcher):
            return IncomingWildcardTraversal()
        return IncomingLabelTraversal(label)


class OutgoingLabelTraversal(Traversal):
    _COGNITIVE_WEIGHT = CognitiveWeight.OUTGOING_LABEL_TRAVERSAL

    def __init__(self, label: Matcher):
        self.label = label

    def __str__(self):
        return f&#34;&gt;{self.label}&#34;

    def children(self):
        return [self.label]

    def tokens(self):
        return [&#34;&gt;&#34;] + self.label.tokens()

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        if self.label.is_hole():
            return [
                OutgoingLabelTraversal(ExactMatcher(v))
                for v in vocabularies.get(config.SYNTAX_FIELD, [])
            ]
        else:
            return []

    def over_approximation(self):
        label = self.label.over_approximation()
        if label is None:
            return None
        if isinstance(label, WildcardMatcher):
            return OutgoingWildcardTraversal()
        return OutgoingLabelTraversal(label)

    def under_approximation(self):
        label = self.label.under_approximation()
        if label is None:
            return None
        if isinstance(label, WildcardMatcher):
            return OutgoingWildcardTraversal()
        return OutgoingLabelTraversal(label)


class ConcatTraversal(Traversal):
    _COGNITIVE_WEIGHT = CognitiveWeight.CONCAT_TRAVERSAL

    def __init__(self, lhs: Traversal, rhs: Traversal):
        self.lhs = lhs
        self.rhs = rhs

    def __str__(self):
        lhs = maybe_parens(self.lhs, OrTraversal)
        rhs = maybe_parens(self.rhs, OrTraversal)
        return f&#34;{lhs} {rhs}&#34;

    def children(self):
        return [self.lhs, self.rhs]

    def tokens(self):
        tokens = []
        tokens += maybe_parens_tokens(self.lhs, OrTraversal)
        tokens += maybe_parens_tokens(self.rhs, OrTraversal)
        return tokens

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        if self.lhs.has_holes():
            nodes = self.lhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [ConcatTraversal(n, self.rhs) for n in nodes]
        elif self.rhs.has_holes():
            nodes = self.rhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [ConcatTraversal(self.lhs, n) for n in nodes]
        else:
            return []

    def permutations(self):
        return get_all_trees(self)

    def over_approximation(self):
        lhs = self.lhs.over_approximation()
        if lhs is None:
            return None
        rhs = self.rhs.over_approximation()
        if rhs is None:
            return None
        return ConcatTraversal(lhs, rhs)

    def under_approximation(self):
        lhs = self.lhs.under_approximation()
        if lhs is None:
            return None
        rhs = self.rhs.under_approximation()
        if rhs is None:
            return None
        return ConcatTraversal(lhs, rhs)

    def unroll(self):
        return ConcatTraversal(self.lhs.unroll(), self.rhs.unroll())

    def split(self):
        results = []
        for lhs in self.lhs.split():
            results.append(ConcatTraversal(lhs, self.rhs))
        for rhs in self.rhs.split():
            results.append(ConcatSurface(self.lhs, rhs))
        return results


class OrTraversal(Traversal):
    _COGNITIVE_WEIGHT = CognitiveWeight.OR_TRAVERSAL

    def __init__(self, lhs: Traversal, rhs: Traversal):
        self.lhs = lhs
        self.rhs = rhs

    def __str__(self):
        return f&#34;{self.lhs} | {self.rhs}&#34;

    def children(self):
        return [self.lhs, self.rhs]

    def tokens(self):
        return self.lhs.tokens() + [&#34;|&#34;] + self.rhs.tokens()

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        if self.lhs.has_holes():
            nodes = self.lhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [OrTraversal(n, self.rhs) for n in nodes]
        elif self.rhs.has_holes():
            nodes = self.rhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [OrTraversal(self.lhs, n) for n in nodes]
        else:
            return []

    def permutations(self):
        return get_all_trees(self)

    def over_approximation(self):
        lhs = self.lhs.over_approximation()
        rhs = self.rhs.over_approximation()
        if lhs is None:
            return rhs
        if rhs is None:
            return lhs
        return OrTraversal(lhs, rhs)

    def under_approximation(self):
        lhs = self.lhs.under_approximation()
        rhs = self.rhs.under_approximation()
        if lhs is None:
            return rhs
        if rhs is None:
            return lhs
        return OrTraversal(lhs, rhs)

    def unroll(self):
        return OrTraversal(self.lhs.unroll(), self.rhs.unroll())

    def split(self):
        return self.lhs.split() + self.rhs.split()


class RepeatTraversal(Traversal):
    _COGNITIVE_WEIGHT = CognitiveWeight.REPEAT_TRAVERSAL

    def __init__(self, traversal: Traversal, min: int, max: Optional[int]):
        self.traversal = traversal
        self.min = min
        self.max = max

    def __str__(self):
        traversal = maybe_parens(self.traversal, (ConcatTraversal, OrTraversal))
        quant = make_quantifier(self.min, self.max)
        return f&#34;{traversal}{quant}&#34;

    def children(self):
        return [self.traversal]

    def id_tuple(self):
        return super().id_tuple() + (self.min, self.max)

    def tokens(self):
        tokens = []
        tokens += maybe_parens_tokens(self.traversal, (ConcatTraversal, OrTraversal))
        tokens += make_quantifier_tokens(self.min, self.max)
        return tokens

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        nodes = self.traversal.expand_leftmost_hole(vocabularies, **kwargs)
        nodes = [n for n in nodes if not isinstance(n, RepeatTraversal)]
        return [RepeatTraversal(n, self.min, self.max) for n in nodes]

    def permutations(self):
        return [
            RepeatTraversal(p, self.min, self.max)
            for p in self.traversal.permutations()
        ]

    def over_approximation(self):
        traversal = self.traversal.over_approximation()
        if traversal is None:
            return None
        return RepeatTraversal(traversal, self.min, self.max)

    def under_approximation(self):
        traversal = self.traversal.under_approximation()
        if traversal is None:
            return None
        return RepeatTraversal(traversal, self.min, self.max)

    def unroll(self):
        if self.min &lt;= 1 and self.max is None:
            return ConcatTraversal(
                self.traversal, ConcatTraversal(self.traversal, self)
            )
        return self

    def num_quantifiers(self):
        return 1 + self.traversal.num_quantifiers()


####################
# query
####################


class Query(AstNode):
    &#34;&#34;&#34;The base class for hybrid queries.&#34;&#34;&#34;


class HoleQuery(Query):
    def __str__(self):
        return config.QUERY_HOLE_GLYPH

    def is_hole(self):
        return True

    def num_query_holes(self):
        return 1

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        return [
            HoleSurface(),
            HybridQuery(HoleSurface(), HoleTraversal(), HoleQuery()),
        ]

    def over_approximation(self):
        raise NotImplementedError()

    def under_approximation(self):
        raise NotImplementedError()


class HybridQuery(Query):
    _COGNITIVE_WEIGHT = CognitiveWeight.HYBRID_QUERY

    def __init__(self, src: Surface, traversal: Traversal, dst: AstNode):
        self.src = src
        self.dst = dst
        self.traversal = traversal

    def __str__(self):
        src = maybe_parens(self.src, OrSurface)
        dst = maybe_parens(self.dst, OrSurface)
        traversal = maybe_parens(self.traversal, OrTraversal)
        return f&#34;{src} {traversal} {dst}&#34;

    def children(self):
        return [self.src, self.traversal, self.dst]

    def tokens(self):
        src = maybe_parens_tokens(self.src, OrSurface)
        dst = maybe_parens_tokens(self.dst, OrSurface)
        traversal = maybe_parens_tokens(self.traversal, OrTraversal)
        return src + traversal + dst

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        if self.src.has_holes():
            nodes = self.src.expand_leftmost_hole(vocabularies, **kwargs)
            return [HybridQuery(n, self.traversal, self.dst) for n in nodes]
        elif self.traversal.has_holes():
            nodes = self.traversal.expand_leftmost_hole(vocabularies, **kwargs)
            return [HybridQuery(self.src, n, self.dst) for n in nodes]
        elif self.dst.has_holes():
            nodes = self.dst.expand_leftmost_hole(vocabularies, **kwargs)
            return [HybridQuery(self.src, self.traversal, n) for n in nodes]
        else:
            return []

    def permutations(self):
        return [
            HybridQuery(src, traversal, dst)
            for src in self.src.permutations()
            for traversal in self.traversal.permutations()
            for dst in self.dst.permutations()
        ]

    def over_approximation(self):
        src = self.src.over_approximation()
        if src is None:
            return None
        traversal = self.traversal.over_approximation()
        if traversal is None:
            return None
        dst = self.dst.over_approximation()
        if dst is None:
            return None
        return HybridQuery(src, traversal, dst)

    def under_approximation(self):
        src = self.src.under_approximation()
        if src is None:
            return None
        traversal = self.traversal.under_approximation()
        if traversal is None:
            return None
        dst = self.dst.under_approximation()
        if dst is None:
            return None
        return HybridQuery(src, traversal, dst)

    def unroll(self):
        return HybridQuery(
            self.src.unroll(),
            self.traversal.unroll(),
            self.dst.unroll(),
        )

    def split(self):
        results = []
        for src in self.src.split():
            results.append(HybridQuery(src, self.traversal, self.dst))
        for traversal in self.traversal.split():
            results.append(HybridQuery(self.src, traversal, self.dst))
        for dst in self.dst.split():
            results.append(HybridQuery(self.src, self.traversal, dst))
        return results</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="odinson.ruleutils.queryast.AndConstraint"><code class="flex name class">
<span>class <span class="ident">AndConstraint</span></span>
<span>(</span><span>lhs:<a title="odinson.ruleutils.queryast.Constraint" href="#odinson.ruleutils.queryast.Constraint">Constraint</a>, rhs:<a title="odinson.ruleutils.queryast.Constraint" href="#odinson.ruleutils.queryast.Constraint">Constraint</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all token constraints.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AndConstraint(Constraint):
    _COGNITIVE_WEIGHT = CognitiveWeight.AND_CONSTRAINT

    def __init__(self, lhs: Constraint, rhs: Constraint):
        self.lhs = lhs
        self.rhs = rhs

    def __str__(self):
        return f&#34;{self.lhs} &amp; {self.rhs}&#34;

    def children(self):
        return [self.lhs, self.rhs]

    def tokens(self):
        tokens = []
        tokens += maybe_parens_tokens(self.lhs, OrConstraint)
        tokens.append(&#34;&amp;&#34;)
        tokens += maybe_parens_tokens(self.rhs, OrConstraint)
        return tokens

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        if self.lhs.has_holes():
            nodes = self.lhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [AndConstraint(n, self.rhs) for n in nodes]
        elif self.rhs.has_holes():
            nodes = self.rhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [AndConstraint(self.lhs, n) for n in nodes]
        else:
            return []

    def permutations(self):
        return get_all_trees(self)

    def over_approximation(self):
        lhs = self.lhs.over_approximation()
        rhs = self.rhs.over_approximation()
        if lhs is None or rhs is None:
            return None
        if isinstance(lhs, WildcardConstraint):
            return rhs
        if isinstance(rhs, WildcardConstraint):
            return lhs
        return AndConstraint(lhs, rhs)

    def under_approximation(self):
        lhs = self.lhs.under_approximation()
        rhs = self.rhs.under_approximation()
        if lhs is None or rhs is None:
            return None
        if isinstance(lhs, WildcardConstraint):
            return rhs
        if isinstance(rhs, WildcardConstraint):
            return lhs
        return AndConstraint(lhs, rhs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Constraint" href="#odinson.ruleutils.queryast.Constraint">Constraint</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="odinson.ruleutils.queryast.AndConstraint.children"><code class="name flex">
<span>def <span class="ident">children</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def children(self):
    return [self.lhs, self.rhs]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Constraint" href="#odinson.ruleutils.queryast.Constraint">Constraint</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Constraint.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode"><code class="flex name class">
<span>class <span class="ident">AstNode</span></span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all AST nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AstNode:
    &#34;&#34;&#34;The base class for all AST nodes.&#34;&#34;&#34;

    def __repr__(self):
        return f&#34;&lt;{self.__class__.__name__}: {str(self)!r}&gt;&#34;

    def __eq__(self, value):
        return self.id_tuple() == value.id_tuple()

    def __hash__(self):
        return hash(self.id_tuple())

    def children(self):
        return []

    def id_tuple(self):
        return (type(self), *self.children())

    def is_hole(self) -&gt; bool:
        &#34;&#34;&#34;Returns true if the node is a hole.&#34;&#34;&#34;
        # most nodes are not holes,
        # so only the Hole* nodes need to override this
        return False

    def has_holes(self) -&gt; bool:
        &#34;&#34;&#34;Returns true if the pattern has one or more holes.&#34;&#34;&#34;
        # most nodes need to override this to handle their children,
        # so the default implementation is intended for Hole* nodes
        return self.is_hole() or any(c.has_holes() for c in self.children())

    def is_valid(self) -&gt; bool:
        &#34;&#34;&#34;Returns true if the pattern is valid, i.e., has no holes.&#34;&#34;&#34;
        return not self.has_holes()

    def tokens(self) -&gt; List[Text]:
        &#34;&#34;&#34;Returns the pattern as a list of tokens.&#34;&#34;&#34;
        # default implementation is intended for nodes that have no children
        return [Text(self)]

    def num_matcher_holes(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of matcher holes in this pattern.&#34;&#34;&#34;
        return sum(c.num_matcher_holes() for c in self.children())

    def num_constraint_holes(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of constraint holes in this pattern.&#34;&#34;&#34;
        return sum(c.num_constraint_holes() for c in self.children())

    def num_surface_holes(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of surface holes in this pattern.&#34;&#34;&#34;
        return sum(c.num_surface_holes() for c in self.children())

    def num_traversal_holes(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of traversal holes in this pattern.&#34;&#34;&#34;
        return sum(c.num_traversal_holes() for c in self.children())

    def num_query_holes(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of traversal holes in this pattern.&#34;&#34;&#34;
        return sum(c.num_query_holes() for c in self.children())

    def num_holes(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of holes in this pattern.&#34;&#34;&#34;
        return (
            self.num_matcher_holes()
            + self.num_constraint_holes()
            + self.num_surface_holes()
            + self.num_traversal_holes()
            + self.num_query_holes()
        )

    def expand_leftmost_hole(
        self, vocabularies: Vocabularies, **kwargs
    ) -&gt; List[AstNode]:
        &#34;&#34;&#34;
        If the pattern has holes then it returns the patterns obtained
        by expanding the leftmost hole.  If there are no holes then it
        returns an empty list.
        &#34;&#34;&#34;
        # default implementation is suitable for Matchers only
        return []

    def preorder_traversal(self) -&gt; List[AstNode]:
        &#34;&#34;&#34;Returns a list with all the nodes of the tree in preorder.&#34;&#34;&#34;
        # default implementation is for nodes that have no children
        return [self] + [c.preorder_traversal() for c in self.children()]

    def permutations(self) -&gt; List[AstNode]:
        &#34;&#34;&#34;Returns all trees that are equivalent to this AstNode.&#34;&#34;&#34;
        return [self]

    def over_approximation(self) -&gt; Optional[AstNode]:
        &#34;&#34;&#34;Returns a rule with a language that contains all the languages
        of the current node&#39;s descendents.&#34;&#34;&#34;
        return self

    def under_approximation(self) -&gt; Optional[AstNode]:
        &#34;&#34;&#34;Returns a rule with a language that is subsumed by the languages
        of all the descendents of the current node&#34;&#34;&#34;
        return self

    def redundancy_patterns(self) -&gt; List[AstNode]:
        return [n.over_approximation() for n in set(self.unroll().split())]

    def unroll(self) -&gt; AstNode:
        &#34;&#34;&#34;unroll repetitions&#34;&#34;&#34;
        return self

    def split(self) -&gt; List[AstNode]:
        &#34;&#34;&#34;decompose rule&#34;&#34;&#34;
        return [self]

    _COGNITIVE_WEIGHT = 0

    def cognitive_weight(self) -&gt; int:
        return self._COGNITIVE_WEIGHT + sum(
            c.cognitive_weight() for c in self.children()
        )

    def operators(self) -&gt; list[str]:
        return [t for t in self.tokens() if t in OPERATORS]

    def operands(self) -&gt; list[str]:
        return [
            t
            for t in self.tokens()
            if t not in OPERATORS and t not in OPERATORS_TO_EXCLUDE
        ]

    def num_operators(self) -&gt; int:
        return len(self.operators())

    def num_distinct_operators(self) -&gt; int:
        return len(set(self.operators()))

    def num_operands(self) -&gt; int:
        return len(self.operands())

    def num_distinct_operands(self) -&gt; int:
        return len(set(self.operands()))

    def implementation_length(self) -&gt; int:
        return self.num_operators() + self.num_operands()

    def vocabulary_length(self) -&gt; int:
        return self.num_distinct_operators() + self.num_distinct_operands()

    def program_length(self) -&gt; float:
        operators = self.num_distinct_operators()
        operands = self.num_distinct_operands()
        return operators * math.log(operators, 2) + operands * math.log(operands, 2)

    def program_volume(self) -&gt; float:
        return self.implementation_length() * math.log(self.vocabulary_length(), 2)

    def potential_volume(self) -&gt; float:
        # NOTE this may not be correct for our language
        x = 2 + self.num_distinct_operands()
        return x * math.log(x, 2)

    def program_level(self) -&gt; float:
        return self.potential_volume() / self.program_volume()

    def effort(self) -&gt; float:
        return self.program_volume() / self.program_level()

    def number_incomings(self) -&gt; int:
        return len([t for t in self.tokens() if t.startswith(&#34;&lt;&#34;)])

    def number_outgoings(self) -&gt; int:
        return len([t for t in self.tokens() if t.startswith(&#34;&gt;&#34;)])

    def proportion_incoming(self) -&gt; float:
        n_in = self.number_incomings()
        n_out = self.number_outgoings()
        return n_in / (n_in + n_out)

    def num_quantifiers(self):
        return sum(c.num_quantifiers() for c in self.children())

    def num_nodes(self) -&gt; int:
        return 1 + sum(c.num_nodes() for c in self.children())

    def num_leaves(self) -&gt; int:
        children = self.children()
        return 1 if not children else sum(c.num_leaves() for c in children)

    def tree_height(self, func):
        height = 0
        children = self.children()
        if children:
            height = func(c.tree_height(func) for c in children)
        return height + 1

    def max_tree_height(self) -&gt; int:
        return self.tree_height(max)

    def min_tree_height(self) -&gt; int:
        return self.tree_height(min)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Constraint" href="#odinson.ruleutils.queryast.Constraint">Constraint</a></li>
<li><a title="odinson.ruleutils.queryast.Matcher" href="#odinson.ruleutils.queryast.Matcher">Matcher</a></li>
<li><a title="odinson.ruleutils.queryast.Query" href="#odinson.ruleutils.queryast.Query">Query</a></li>
<li><a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a></li>
<li><a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="odinson.ruleutils.queryast.AstNode.children"><code class="name flex">
<span>def <span class="ident">children</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def children(self):
    return []</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.cognitive_weight"><code class="name flex">
<span>def <span class="ident">cognitive_weight</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cognitive_weight(self) -&gt; int:
    return self._COGNITIVE_WEIGHT + sum(
        c.cognitive_weight() for c in self.children()
    )</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.effort"><code class="name flex">
<span>def <span class="ident">effort</span></span>(<span>self) >float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def effort(self) -&gt; float:
    return self.program_volume() / self.program_level()</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.expand_leftmost_hole"><code class="name flex">
<span>def <span class="ident">expand_leftmost_hole</span></span>(<span>self, vocabularies:Vocabularies, **kwargs) >List[<a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>If the pattern has holes then it returns the patterns obtained
by expanding the leftmost hole.
If there are no holes then it
returns an empty list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expand_leftmost_hole(
    self, vocabularies: Vocabularies, **kwargs
) -&gt; List[AstNode]:
    &#34;&#34;&#34;
    If the pattern has holes then it returns the patterns obtained
    by expanding the leftmost hole.  If there are no holes then it
    returns an empty list.
    &#34;&#34;&#34;
    # default implementation is suitable for Matchers only
    return []</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.has_holes"><code class="name flex">
<span>def <span class="ident">has_holes</span></span>(<span>self) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the pattern has one or more holes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_holes(self) -&gt; bool:
    &#34;&#34;&#34;Returns true if the pattern has one or more holes.&#34;&#34;&#34;
    # most nodes need to override this to handle their children,
    # so the default implementation is intended for Hole* nodes
    return self.is_hole() or any(c.has_holes() for c in self.children())</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.id_tuple"><code class="name flex">
<span>def <span class="ident">id_tuple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_tuple(self):
    return (type(self), *self.children())</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.implementation_length"><code class="name flex">
<span>def <span class="ident">implementation_length</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def implementation_length(self) -&gt; int:
    return self.num_operators() + self.num_operands()</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.is_hole"><code class="name flex">
<span>def <span class="ident">is_hole</span></span>(<span>self) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the node is a hole.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_hole(self) -&gt; bool:
    &#34;&#34;&#34;Returns true if the node is a hole.&#34;&#34;&#34;
    # most nodes are not holes,
    # so only the Hole* nodes need to override this
    return False</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.is_valid"><code class="name flex">
<span>def <span class="ident">is_valid</span></span>(<span>self) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the pattern is valid, i.e., has no holes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid(self) -&gt; bool:
    &#34;&#34;&#34;Returns true if the pattern is valid, i.e., has no holes.&#34;&#34;&#34;
    return not self.has_holes()</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.max_tree_height"><code class="name flex">
<span>def <span class="ident">max_tree_height</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max_tree_height(self) -&gt; int:
    return self.tree_height(max)</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.min_tree_height"><code class="name flex">
<span>def <span class="ident">min_tree_height</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min_tree_height(self) -&gt; int:
    return self.tree_height(min)</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.num_constraint_holes"><code class="name flex">
<span>def <span class="ident">num_constraint_holes</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of constraint holes in this pattern.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_constraint_holes(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of constraint holes in this pattern.&#34;&#34;&#34;
    return sum(c.num_constraint_holes() for c in self.children())</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.num_distinct_operands"><code class="name flex">
<span>def <span class="ident">num_distinct_operands</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_distinct_operands(self) -&gt; int:
    return len(set(self.operands()))</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.num_distinct_operators"><code class="name flex">
<span>def <span class="ident">num_distinct_operators</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_distinct_operators(self) -&gt; int:
    return len(set(self.operators()))</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.num_holes"><code class="name flex">
<span>def <span class="ident">num_holes</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of holes in this pattern.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_holes(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of holes in this pattern.&#34;&#34;&#34;
    return (
        self.num_matcher_holes()
        + self.num_constraint_holes()
        + self.num_surface_holes()
        + self.num_traversal_holes()
        + self.num_query_holes()
    )</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.num_leaves"><code class="name flex">
<span>def <span class="ident">num_leaves</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_leaves(self) -&gt; int:
    children = self.children()
    return 1 if not children else sum(c.num_leaves() for c in children)</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.num_matcher_holes"><code class="name flex">
<span>def <span class="ident">num_matcher_holes</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of matcher holes in this pattern.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_matcher_holes(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of matcher holes in this pattern.&#34;&#34;&#34;
    return sum(c.num_matcher_holes() for c in self.children())</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.num_nodes"><code class="name flex">
<span>def <span class="ident">num_nodes</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_nodes(self) -&gt; int:
    return 1 + sum(c.num_nodes() for c in self.children())</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.num_operands"><code class="name flex">
<span>def <span class="ident">num_operands</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_operands(self) -&gt; int:
    return len(self.operands())</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.num_operators"><code class="name flex">
<span>def <span class="ident">num_operators</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_operators(self) -&gt; int:
    return len(self.operators())</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.num_quantifiers"><code class="name flex">
<span>def <span class="ident">num_quantifiers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_quantifiers(self):
    return sum(c.num_quantifiers() for c in self.children())</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.num_query_holes"><code class="name flex">
<span>def <span class="ident">num_query_holes</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of traversal holes in this pattern.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_query_holes(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of traversal holes in this pattern.&#34;&#34;&#34;
    return sum(c.num_query_holes() for c in self.children())</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.num_surface_holes"><code class="name flex">
<span>def <span class="ident">num_surface_holes</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of surface holes in this pattern.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_surface_holes(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of surface holes in this pattern.&#34;&#34;&#34;
    return sum(c.num_surface_holes() for c in self.children())</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.num_traversal_holes"><code class="name flex">
<span>def <span class="ident">num_traversal_holes</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of traversal holes in this pattern.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_traversal_holes(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of traversal holes in this pattern.&#34;&#34;&#34;
    return sum(c.num_traversal_holes() for c in self.children())</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.number_incomings"><code class="name flex">
<span>def <span class="ident">number_incomings</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def number_incomings(self) -&gt; int:
    return len([t for t in self.tokens() if t.startswith(&#34;&lt;&#34;)])</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.number_outgoings"><code class="name flex">
<span>def <span class="ident">number_outgoings</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def number_outgoings(self) -&gt; int:
    return len([t for t in self.tokens() if t.startswith(&#34;&gt;&#34;)])</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.operands"><code class="name flex">
<span>def <span class="ident">operands</span></span>(<span>self) >list[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def operands(self) -&gt; list[str]:
    return [
        t
        for t in self.tokens()
        if t not in OPERATORS and t not in OPERATORS_TO_EXCLUDE
    ]</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.operators"><code class="name flex">
<span>def <span class="ident">operators</span></span>(<span>self) >list[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def operators(self) -&gt; list[str]:
    return [t for t in self.tokens() if t in OPERATORS]</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.over_approximation"><code class="name flex">
<span>def <span class="ident">over_approximation</span></span>(<span>self) >Optional[<a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a rule with a language that contains all the languages
of the current node's descendents.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def over_approximation(self) -&gt; Optional[AstNode]:
    &#34;&#34;&#34;Returns a rule with a language that contains all the languages
    of the current node&#39;s descendents.&#34;&#34;&#34;
    return self</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.permutations"><code class="name flex">
<span>def <span class="ident">permutations</span></span>(<span>self) >List[<a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all trees that are equivalent to this AstNode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def permutations(self) -&gt; List[AstNode]:
    &#34;&#34;&#34;Returns all trees that are equivalent to this AstNode.&#34;&#34;&#34;
    return [self]</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.potential_volume"><code class="name flex">
<span>def <span class="ident">potential_volume</span></span>(<span>self) >float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def potential_volume(self) -&gt; float:
    # NOTE this may not be correct for our language
    x = 2 + self.num_distinct_operands()
    return x * math.log(x, 2)</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.preorder_traversal"><code class="name flex">
<span>def <span class="ident">preorder_traversal</span></span>(<span>self) >List[<a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list with all the nodes of the tree in preorder.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preorder_traversal(self) -&gt; List[AstNode]:
    &#34;&#34;&#34;Returns a list with all the nodes of the tree in preorder.&#34;&#34;&#34;
    # default implementation is for nodes that have no children
    return [self] + [c.preorder_traversal() for c in self.children()]</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.program_length"><code class="name flex">
<span>def <span class="ident">program_length</span></span>(<span>self) >float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def program_length(self) -&gt; float:
    operators = self.num_distinct_operators()
    operands = self.num_distinct_operands()
    return operators * math.log(operators, 2) + operands * math.log(operands, 2)</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.program_level"><code class="name flex">
<span>def <span class="ident">program_level</span></span>(<span>self) >float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def program_level(self) -&gt; float:
    return self.potential_volume() / self.program_volume()</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.program_volume"><code class="name flex">
<span>def <span class="ident">program_volume</span></span>(<span>self) >float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def program_volume(self) -&gt; float:
    return self.implementation_length() * math.log(self.vocabulary_length(), 2)</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.proportion_incoming"><code class="name flex">
<span>def <span class="ident">proportion_incoming</span></span>(<span>self) >float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def proportion_incoming(self) -&gt; float:
    n_in = self.number_incomings()
    n_out = self.number_outgoings()
    return n_in / (n_in + n_out)</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.redundancy_patterns"><code class="name flex">
<span>def <span class="ident">redundancy_patterns</span></span>(<span>self) >List[<a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def redundancy_patterns(self) -&gt; List[AstNode]:
    return [n.over_approximation() for n in set(self.unroll().split())]</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>self) >List[<a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>decompose rule</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(self) -&gt; List[AstNode]:
    &#34;&#34;&#34;decompose rule&#34;&#34;&#34;
    return [self]</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.tokens"><code class="name flex">
<span>def <span class="ident">tokens</span></span>(<span>self) >List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the pattern as a list of tokens.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tokens(self) -&gt; List[Text]:
    &#34;&#34;&#34;Returns the pattern as a list of tokens.&#34;&#34;&#34;
    # default implementation is intended for nodes that have no children
    return [Text(self)]</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.tree_height"><code class="name flex">
<span>def <span class="ident">tree_height</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tree_height(self, func):
    height = 0
    children = self.children()
    if children:
        height = func(c.tree_height(func) for c in children)
    return height + 1</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.under_approximation"><code class="name flex">
<span>def <span class="ident">under_approximation</span></span>(<span>self) >Optional[<a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a rule with a language that is subsumed by the languages
of all the descendents of the current node</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def under_approximation(self) -&gt; Optional[AstNode]:
    &#34;&#34;&#34;Returns a rule with a language that is subsumed by the languages
    of all the descendents of the current node&#34;&#34;&#34;
    return self</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.unroll"><code class="name flex">
<span>def <span class="ident">unroll</span></span>(<span>self) ><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>unroll repetitions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unroll(self) -&gt; AstNode:
    &#34;&#34;&#34;unroll repetitions&#34;&#34;&#34;
    return self</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.AstNode.vocabulary_length"><code class="name flex">
<span>def <span class="ident">vocabulary_length</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vocabulary_length(self) -&gt; int:
    return self.num_distinct_operators() + self.num_distinct_operands()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="odinson.ruleutils.queryast.ConcatSurface"><code class="flex name class">
<span>class <span class="ident">ConcatSurface</span></span>
<span>(</span><span>lhs:<a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a>, rhs:<a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all surface patterns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConcatSurface(Surface):
    _COGNITIVE_WEIGHT = CognitiveWeight.CONCAT_SURFACE

    def __init__(self, lhs: Surface, rhs: Surface):
        self.lhs = lhs
        self.rhs = rhs

    def __str__(self):
        lhs = maybe_parens(self.lhs, OrSurface)
        rhs = maybe_parens(self.rhs, OrSurface)
        return f&#34;{lhs} {rhs}&#34;

    def children(self):
        return [self.lhs, self.rhs]

    def tokens(self):
        tokens = []
        tokens += maybe_parens_tokens(self.lhs, OrSurface)
        tokens += maybe_parens_tokens(self.rhs, OrSurface)
        return tokens

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        if self.lhs.has_holes():
            nodes = self.lhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [ConcatSurface(n, self.rhs) for n in nodes]
        elif self.rhs.has_holes():
            nodes = self.rhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [ConcatSurface(self.lhs, n) for n in nodes]
        else:
            return []

    def permutations(self):
        return get_all_trees(self)

    def over_approximation(self):
        lhs = self.lhs.over_approximation()
        if lhs is None:
            return None
        rhs = self.rhs.over_approximation()
        if rhs is None:
            return None
        return ConcatSurface(lhs, rhs)

    def under_approximation(self):
        lhs = self.lhs.under_approximation()
        if lhs is None:
            return None
        rhs = self.rhs.under_approximation()
        if rhs is None:
            return None
        return ConcatSurface(lhs, rhs)

    def unroll(self):
        return ConcatSurface(self.lhs.unroll(), self.rhs.unroll())

    def split(self):
        results = []
        for lhs in self.lhs.split():
            results.append(ConcatSurface(lhs, self.rhs))
        for rhs in self.rhs.split():
            results.append(ConcatSurface(self.lhs, rhs))
        return results</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="odinson.ruleutils.queryast.ConcatSurface.children"><code class="name flex">
<span>def <span class="ident">children</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def children(self):
    return [self.lhs, self.rhs]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Surface.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.ConcatTraversal"><code class="flex name class">
<span>class <span class="ident">ConcatTraversal</span></span>
<span>(</span><span>lhs:<a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a>, rhs:<a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all graph traversals.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConcatTraversal(Traversal):
    _COGNITIVE_WEIGHT = CognitiveWeight.CONCAT_TRAVERSAL

    def __init__(self, lhs: Traversal, rhs: Traversal):
        self.lhs = lhs
        self.rhs = rhs

    def __str__(self):
        lhs = maybe_parens(self.lhs, OrTraversal)
        rhs = maybe_parens(self.rhs, OrTraversal)
        return f&#34;{lhs} {rhs}&#34;

    def children(self):
        return [self.lhs, self.rhs]

    def tokens(self):
        tokens = []
        tokens += maybe_parens_tokens(self.lhs, OrTraversal)
        tokens += maybe_parens_tokens(self.rhs, OrTraversal)
        return tokens

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        if self.lhs.has_holes():
            nodes = self.lhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [ConcatTraversal(n, self.rhs) for n in nodes]
        elif self.rhs.has_holes():
            nodes = self.rhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [ConcatTraversal(self.lhs, n) for n in nodes]
        else:
            return []

    def permutations(self):
        return get_all_trees(self)

    def over_approximation(self):
        lhs = self.lhs.over_approximation()
        if lhs is None:
            return None
        rhs = self.rhs.over_approximation()
        if rhs is None:
            return None
        return ConcatTraversal(lhs, rhs)

    def under_approximation(self):
        lhs = self.lhs.under_approximation()
        if lhs is None:
            return None
        rhs = self.rhs.under_approximation()
        if rhs is None:
            return None
        return ConcatTraversal(lhs, rhs)

    def unroll(self):
        return ConcatTraversal(self.lhs.unroll(), self.rhs.unroll())

    def split(self):
        results = []
        for lhs in self.lhs.split():
            results.append(ConcatTraversal(lhs, self.rhs))
        for rhs in self.rhs.split():
            results.append(ConcatSurface(self.lhs, rhs))
        return results</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="odinson.ruleutils.queryast.ConcatTraversal.children"><code class="name flex">
<span>def <span class="ident">children</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def children(self):
    return [self.lhs, self.rhs]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Traversal.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.Constraint"><code class="flex name class">
<span>class <span class="ident">Constraint</span></span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all token constraints.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Constraint(AstNode):
    &#34;&#34;&#34;The base class for all token constraints.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.AndConstraint" href="#odinson.ruleutils.queryast.AndConstraint">AndConstraint</a></li>
<li><a title="odinson.ruleutils.queryast.FieldConstraint" href="#odinson.ruleutils.queryast.FieldConstraint">FieldConstraint</a></li>
<li><a title="odinson.ruleutils.queryast.HoleConstraint" href="#odinson.ruleutils.queryast.HoleConstraint">HoleConstraint</a></li>
<li><a title="odinson.ruleutils.queryast.NotConstraint" href="#odinson.ruleutils.queryast.NotConstraint">NotConstraint</a></li>
<li><a title="odinson.ruleutils.queryast.OrConstraint" href="#odinson.ruleutils.queryast.OrConstraint">OrConstraint</a></li>
<li><a title="odinson.ruleutils.queryast.WildcardConstraint" href="#odinson.ruleutils.queryast.WildcardConstraint">WildcardConstraint</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.AstNode.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.ExactMatcher"><code class="flex name class">
<span>class <span class="ident">ExactMatcher</span></span>
<span>(</span><span>s:Text)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all string matchers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExactMatcher(Matcher):
    def __init__(self, s: Text):
        self.string = s

    def __str__(self):
        if is_identifier(self.string):
            # don&#39;t surround identifiers with quotes
            return self.string
        else:
            return json.dumps(self.string)

    def id_tuple(self):
        return super().id_tuple() + (self.string,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Matcher" href="#odinson.ruleutils.queryast.Matcher">Matcher</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="odinson.ruleutils.queryast.ExactMatcher.id_tuple"><code class="name flex">
<span>def <span class="ident">id_tuple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_tuple(self):
    return super().id_tuple() + (self.string,)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Matcher" href="#odinson.ruleutils.queryast.Matcher">Matcher</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Matcher.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.FieldConstraint"><code class="flex name class">
<span>class <span class="ident">FieldConstraint</span></span>
<span>(</span><span>name:<a title="odinson.ruleutils.queryast.Matcher" href="#odinson.ruleutils.queryast.Matcher">Matcher</a>, value:<a title="odinson.ruleutils.queryast.Matcher" href="#odinson.ruleutils.queryast.Matcher">Matcher</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all token constraints.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FieldConstraint(Constraint):
    _COGNITIVE_WEIGHT = CognitiveWeight.FIELD_CONSTRAINT

    def __init__(self, name: Matcher, value: Matcher):
        self.name = name
        self.value = value

    def __str__(self):
        return f&#34;{self.name}={self.value}&#34;

    def children(self):
        return [self.name, self.value]

    def tokens(self):
        return self.name.tokens() + [&#34;=&#34;] + self.value.tokens()

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        if self.name.is_hole():
            return [
                FieldConstraint(ExactMatcher(name), self.value)
                for name in vocabularies
                if name not in config.EXCLUDE_FIELDS
            ]
        elif self.value.is_hole():
            return [
                FieldConstraint(self.name, ExactMatcher(value))
                for value in vocabularies[self.name.string]
            ]
        else:
            return []

    def over_approximation(self):
        name = self.name.over_approximation()
        if name is None:
            return None
        if isinstance(name, WildcardMatcher):
            return WildcardConstraint()
        value = self.value.over_approximation()
        if value is None:
            return None
        if isinstance(value, WildcardMatcher):
            return WildcardConstraint()
        return FieldConstraint(name, value)

    def under_approximation(self):
        name = self.name.under_approximation()
        if name is None:
            return None
        if isinstance(name, WildcardMatcher):
            return WildcardConstraint()
        value = self.value.under_approximation()
        if value is None:
            return None
        if isinstance(value, WildcardMatcher):
            return WildcardConstraint()
        return FieldConstraint(name, value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Constraint" href="#odinson.ruleutils.queryast.Constraint">Constraint</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="odinson.ruleutils.queryast.FieldConstraint.children"><code class="name flex">
<span>def <span class="ident">children</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def children(self):
    return [self.name, self.value]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Constraint" href="#odinson.ruleutils.queryast.Constraint">Constraint</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Constraint.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.HoleConstraint"><code class="flex name class">
<span>class <span class="ident">HoleConstraint</span></span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all token constraints.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HoleConstraint(Constraint):
    def __str__(self):
        return config.SURFACE_HOLE_GLYPH

    def is_hole(self):
        return True

    def num_constraint_holes(self):
        return 1

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        return [
            FieldConstraint(HoleMatcher(), HoleMatcher()),
            NotConstraint(HoleConstraint()),
            AndConstraint(HoleConstraint(), HoleConstraint()),
            OrConstraint(HoleConstraint(), HoleConstraint()),
        ]

    def over_approximation(self):
        return WildcardConstraint()

    def under_approximation(self):
        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Constraint" href="#odinson.ruleutils.queryast.Constraint">Constraint</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Constraint" href="#odinson.ruleutils.queryast.Constraint">Constraint</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Constraint.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.HoleMatcher"><code class="flex name class">
<span>class <span class="ident">HoleMatcher</span></span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all string matchers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HoleMatcher(Matcher):
    def __str__(self):
        return config.SURFACE_HOLE_GLYPH

    def is_hole(self):
        return True

    def num_matcher_holes(self):
        return 1

    def over_approximation(self):
        return WildcardMatcher()

    def under_approximation(self):
        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Matcher" href="#odinson.ruleutils.queryast.Matcher">Matcher</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Matcher" href="#odinson.ruleutils.queryast.Matcher">Matcher</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Matcher.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Matcher.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.HoleQuery"><code class="flex name class">
<span>class <span class="ident">HoleQuery</span></span>
</code></dt>
<dd>
<div class="desc"><p>The base class for hybrid queries.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HoleQuery(Query):
    def __str__(self):
        return config.QUERY_HOLE_GLYPH

    def is_hole(self):
        return True

    def num_query_holes(self):
        return 1

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        return [
            HoleSurface(),
            HybridQuery(HoleSurface(), HoleTraversal(), HoleQuery()),
        ]

    def over_approximation(self):
        raise NotImplementedError()

    def under_approximation(self):
        raise NotImplementedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Query" href="#odinson.ruleutils.queryast.Query">Query</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Query" href="#odinson.ruleutils.queryast.Query">Query</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Query.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.HoleSurface"><code class="flex name class">
<span>class <span class="ident">HoleSurface</span></span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all surface patterns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HoleSurface(Surface):
    def __str__(self):
        return config.SURFACE_HOLE_GLYPH

    def is_hole(self):
        return True

    def num_surface_holes(self):
        return 1

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        candidates = [
            TokenSurface(HoleConstraint()),
        ]
        if kwargs.get(&#34;allow_surface_wildcards&#34;, True):
            candidates.append(WildcardSurface())
        if (
            kwargs.get(&#34;allow_surface_mentions&#34;, True)
            and config.ENTITY_FIELD in vocabularies
        ):
            candidates.append(MentionSurface(HoleMatcher()))
        if kwargs.get(&#34;allow_surface_alternations&#34;, True):
            candidates.append(OrSurface(HoleSurface(), HoleSurface()))
        if kwargs.get(&#34;allow_surface_concatenations&#34;, True):
            candidates.append(ConcatSurface(HoleSurface(), HoleSurface()))
        if kwargs.get(&#34;allow_surface_repetitions&#34;, True):
            candidates += [
                RepeatSurface(HoleSurface(), 0, 1),
                RepeatSurface(HoleSurface(), 0, None),
                RepeatSurface(HoleSurface(), 1, None),
            ]
        return candidates

    def over_approximation(self):
        return RepeatSurface(WildcardSurface(), 0, None)

    def under_approximation(self):
        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Surface.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.HoleTraversal"><code class="flex name class">
<span>class <span class="ident">HoleTraversal</span></span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all graph traversals.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HoleTraversal(Traversal):
    def __str__(self):
        return config.TRAVERSAL_HOLE_GLYPH

    def is_hole(self):
        return True

    def num_traversal_holes(self):
        return 1

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        candidates = [
            IncomingLabelTraversal(HoleMatcher()),
            OutgoingLabelTraversal(HoleMatcher()),
        ]
        if kwargs.get(&#34;allow_traversal_wildcards&#34;, True):
            candidates += [
                IncomingWildcardTraversal(),
                OutgoingWildcardTraversal(),
            ]
        if kwargs.get(&#34;allow_traversal_alternations&#34;, True):
            candidates.append(OrTraversal(HoleTraversal(), HoleTraversal()))
        if kwargs.get(&#34;allow_traversal_concatenations&#34;, True):
            candidates.append(ConcatTraversal(HoleTraversal(), HoleTraversal()))
        if kwargs.get(&#34;allow_traversal_repetitions&#34;, True):
            candidates += [
                RepeatTraversal(HoleTraversal(), 0, 1),
                RepeatTraversal(HoleTraversal(), 0, None),
                RepeatTraversal(HoleTraversal(), 1, None),
            ]
        return candidates

    def over_approximation(self):
        return RepeatTraversal(
            OrTraversal(IncomingWildcardTraversal(), OutgoingWildcardTraversal()),
            0,
            None,
        )

    def under_approximation(self):
        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Traversal.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.HybridQuery"><code class="flex name class">
<span>class <span class="ident">HybridQuery</span></span>
<span>(</span><span>src:<a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a>, traversal:<a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a>, dst:<a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for hybrid queries.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HybridQuery(Query):
    _COGNITIVE_WEIGHT = CognitiveWeight.HYBRID_QUERY

    def __init__(self, src: Surface, traversal: Traversal, dst: AstNode):
        self.src = src
        self.dst = dst
        self.traversal = traversal

    def __str__(self):
        src = maybe_parens(self.src, OrSurface)
        dst = maybe_parens(self.dst, OrSurface)
        traversal = maybe_parens(self.traversal, OrTraversal)
        return f&#34;{src} {traversal} {dst}&#34;

    def children(self):
        return [self.src, self.traversal, self.dst]

    def tokens(self):
        src = maybe_parens_tokens(self.src, OrSurface)
        dst = maybe_parens_tokens(self.dst, OrSurface)
        traversal = maybe_parens_tokens(self.traversal, OrTraversal)
        return src + traversal + dst

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        if self.src.has_holes():
            nodes = self.src.expand_leftmost_hole(vocabularies, **kwargs)
            return [HybridQuery(n, self.traversal, self.dst) for n in nodes]
        elif self.traversal.has_holes():
            nodes = self.traversal.expand_leftmost_hole(vocabularies, **kwargs)
            return [HybridQuery(self.src, n, self.dst) for n in nodes]
        elif self.dst.has_holes():
            nodes = self.dst.expand_leftmost_hole(vocabularies, **kwargs)
            return [HybridQuery(self.src, self.traversal, n) for n in nodes]
        else:
            return []

    def permutations(self):
        return [
            HybridQuery(src, traversal, dst)
            for src in self.src.permutations()
            for traversal in self.traversal.permutations()
            for dst in self.dst.permutations()
        ]

    def over_approximation(self):
        src = self.src.over_approximation()
        if src is None:
            return None
        traversal = self.traversal.over_approximation()
        if traversal is None:
            return None
        dst = self.dst.over_approximation()
        if dst is None:
            return None
        return HybridQuery(src, traversal, dst)

    def under_approximation(self):
        src = self.src.under_approximation()
        if src is None:
            return None
        traversal = self.traversal.under_approximation()
        if traversal is None:
            return None
        dst = self.dst.under_approximation()
        if dst is None:
            return None
        return HybridQuery(src, traversal, dst)

    def unroll(self):
        return HybridQuery(
            self.src.unroll(),
            self.traversal.unroll(),
            self.dst.unroll(),
        )

    def split(self):
        results = []
        for src in self.src.split():
            results.append(HybridQuery(src, self.traversal, self.dst))
        for traversal in self.traversal.split():
            results.append(HybridQuery(self.src, traversal, self.dst))
        for dst in self.dst.split():
            results.append(HybridQuery(self.src, self.traversal, dst))
        return results</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Query" href="#odinson.ruleutils.queryast.Query">Query</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="odinson.ruleutils.queryast.HybridQuery.children"><code class="name flex">
<span>def <span class="ident">children</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def children(self):
    return [self.src, self.traversal, self.dst]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Query" href="#odinson.ruleutils.queryast.Query">Query</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Query.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Query.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.IncomingLabelTraversal"><code class="flex name class">
<span>class <span class="ident">IncomingLabelTraversal</span></span>
<span>(</span><span>label:<a title="odinson.ruleutils.queryast.Matcher" href="#odinson.ruleutils.queryast.Matcher">Matcher</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all graph traversals.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IncomingLabelTraversal(Traversal):
    _COGNITIVE_WEIGHT = CognitiveWeight.INCOMING_LABEL_TRAVERSAL

    def __init__(self, label: Matcher):
        self.label = label

    def __str__(self):
        return f&#34;&lt;{self.label}&#34;

    def children(self):
        return [self.label]

    def tokens(self):
        return [&#34;&lt;&#34;] + self.label.tokens()

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        if self.label.is_hole():
            return [
                IncomingLabelTraversal(ExactMatcher(v))
                for v in vocabularies.get(config.SYNTAX_FIELD, [])
            ]
        else:
            return []

    def over_approximation(self):
        label = self.label.over_approximation()
        if label is None:
            return None
        if isinstance(label, WildcardMatcher):
            return IncomingWildcardTraversal()
        return IncomingLabelTraversal(label)

    def under_approximation(self):
        label = self.label.under_approximation()
        if label is None:
            return None
        if isinstance(label, WildcardMatcher):
            return IncomingWildcardTraversal()
        return IncomingLabelTraversal(label)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="odinson.ruleutils.queryast.IncomingLabelTraversal.children"><code class="name flex">
<span>def <span class="ident">children</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def children(self):
    return [self.label]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Traversal.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.IncomingWildcardTraversal"><code class="flex name class">
<span>class <span class="ident">IncomingWildcardTraversal</span></span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all graph traversals.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IncomingWildcardTraversal(Traversal):
    _COGNITIVE_WEIGHT = CognitiveWeight.INCOMING_WILDCARD_TRAVERSAL

    def __str__(self):
        return &#34;&lt;&lt;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Traversal.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.Matcher"><code class="flex name class">
<span>class <span class="ident">Matcher</span></span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all string matchers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Matcher(AstNode):
    &#34;&#34;&#34;The base class for all string matchers.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.ExactMatcher" href="#odinson.ruleutils.queryast.ExactMatcher">ExactMatcher</a></li>
<li><a title="odinson.ruleutils.queryast.HoleMatcher" href="#odinson.ruleutils.queryast.HoleMatcher">HoleMatcher</a></li>
<li>odinson.ruleutils.queryast.WildcardMatcher</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.AstNode.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.MentionSurface"><code class="flex name class">
<span>class <span class="ident">MentionSurface</span></span>
<span>(</span><span>label:<a title="odinson.ruleutils.queryast.Matcher" href="#odinson.ruleutils.queryast.Matcher">Matcher</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all surface patterns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MentionSurface(Surface):
    _COGNITIVE_WEIGHT = CognitiveWeight.MENTION_SURFACE

    def __init__(self, label: Matcher):
        self.label = label

    def __str__(self):
        return f&#34;@{self.label}&#34;

    def children(self):
        return [self.label]

    def tokens(self):
        return [&#34;@&#34;] + self.label.tokens()

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        entities = vocabularies.get(config.ENTITY_FIELD, [])
        return [MentionSurface(ExactMatcher(e)) for e in entities]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="odinson.ruleutils.queryast.MentionSurface.children"><code class="name flex">
<span>def <span class="ident">children</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def children(self):
    return [self.label]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Surface.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.NotConstraint"><code class="flex name class">
<span>class <span class="ident">NotConstraint</span></span>
<span>(</span><span>c:<a title="odinson.ruleutils.queryast.Constraint" href="#odinson.ruleutils.queryast.Constraint">Constraint</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all token constraints.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NotConstraint(Constraint):
    _COGNITIVE_WEIGHT = CognitiveWeight.NOT_CONSTRAINT

    def __init__(self, c: Constraint):
        self.constraint = c

    def __str__(self):
        c = maybe_parens(self.constraint, (AndConstraint, OrConstraint))
        return f&#34;!{c}&#34;

    def children(self):
        return [self.constraint]

    def tokens(self):
        return [&#34;!&#34;] + maybe_parens_tokens(
            self.constraint, (AndConstraint, OrConstraint)
        )

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        # get the next nodes for the nested constraint
        nodes = self.constraint.expand_leftmost_hole(vocabularies, **kwargs)
        # avoid nesting negations
        return [NotConstraint(n) for n in nodes if not isinstance(n, NotConstraint)]

    def permutations(self):
        return [NotConstraint(p) for p in self.constraint.permutations()]

    def over_approximation(self):
        constraint = self.constraint.over_approximation()
        if constraint is None:
            return WildcardConstraint()
        if isinstance(constraint, WildcardConstraint):
            return None
        return NotConstraint(constraint)

    def under_approximation(self):
        constraint = self.constraint.under_approximation()
        if constraint is None:
            return WildcardConstraint()
        if isinstance(constraint, WildcardConstraint):
            return None
        return NotConstraint(constraint)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Constraint" href="#odinson.ruleutils.queryast.Constraint">Constraint</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="odinson.ruleutils.queryast.NotConstraint.children"><code class="name flex">
<span>def <span class="ident">children</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def children(self):
    return [self.constraint]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Constraint" href="#odinson.ruleutils.queryast.Constraint">Constraint</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Constraint.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.OrConstraint"><code class="flex name class">
<span>class <span class="ident">OrConstraint</span></span>
<span>(</span><span>lhs:<a title="odinson.ruleutils.queryast.Constraint" href="#odinson.ruleutils.queryast.Constraint">Constraint</a>, rhs:<a title="odinson.ruleutils.queryast.Constraint" href="#odinson.ruleutils.queryast.Constraint">Constraint</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all token constraints.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OrConstraint(Constraint):
    _COGNITIVE_WEIGHT = CognitiveWeight.OR_CONSTRAINT

    def __init__(self, lhs: Constraint, rhs: Constraint):
        self.lhs = lhs
        self.rhs = rhs

    def __str__(self):
        return f&#34;{self.lhs} | {self.rhs}&#34;

    def children(self):
        return [self.lhs, self.rhs]

    def tokens(self):
        return [*self.lhs.tokens(), &#34;|&#34;, *self.rhs.tokens()]

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        if self.lhs.has_holes():
            nodes = self.lhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [OrConstraint(n, self.rhs) for n in nodes]
        elif self.rhs.has_holes():
            nodes = self.rhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [OrConstraint(self.lhs, n) for n in nodes]
        else:
            return []

    def permutations(self):
        return get_all_trees(self)

    def over_approximation(self):
        lhs = self.lhs.over_approximation()
        rhs = self.rhs.over_approximation()
        if lhs is None:
            return rhs
        if rhs is None:
            return lhs
        if isinstance(lhs, WildcardConstraint) or isinstance(rhs, WildcardConstraint):
            return WildcardConstraint()
        return OrConstraint(lhs, rhs)

    def under_approximation(self):
        lhs = self.lhs.under_approximation()
        rhs = self.rhs.under_approximation()
        if lhs is None:
            return rhs
        if rhs is None:
            return lhs
        if isinstance(lhs, WildcardConstraint) or isinstance(rhs, WildcardConstraint):
            return WildcardConstraint()
        return OrConstraint(lhs, rhs)

    def split(self):
        return self.lhs.split() + self.rhs.split()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Constraint" href="#odinson.ruleutils.queryast.Constraint">Constraint</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="odinson.ruleutils.queryast.OrConstraint.children"><code class="name flex">
<span>def <span class="ident">children</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def children(self):
    return [self.lhs, self.rhs]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Constraint" href="#odinson.ruleutils.queryast.Constraint">Constraint</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Constraint.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.OrSurface"><code class="flex name class">
<span>class <span class="ident">OrSurface</span></span>
<span>(</span><span>lhs:<a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a>, rhs:<a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all surface patterns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OrSurface(Surface):
    _COGNITIVE_WEIGHT = CognitiveWeight.OR_SURFACE

    def __init__(self, lhs: Surface, rhs: Surface):
        self.lhs = lhs
        self.rhs = rhs

    def __str__(self):
        return f&#34;{self.lhs} | {self.rhs}&#34;

    def children(self):
        return [self.lhs, self.rhs]

    def tokens(self):
        return [*self.lhs.tokens(), &#34;|&#34;, *self.rhs.tokens()]

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        if self.lhs.has_holes():
            nodes = self.lhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [OrSurface(n, self.rhs) for n in nodes]
        elif self.rhs.has_holes():
            nodes = self.rhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [OrSurface(self.lhs, n) for n in nodes]
        else:
            return []

    def permutations(self):
        return get_all_trees(self)

    def over_approximation(self):
        lhs = self.lhs.over_approximation()
        rhs = self.rhs.over_approximation()
        if lhs is None:
            return rhs
        if rhs is None:
            return lhs
        return OrSurface(lhs, rhs)

    def under_approximation(self):
        lhs = self.lhs.under_approximation()
        rhs = self.rhs.under_approximation()
        if lhs is None:
            return rhs
        if rhs is None:
            return lhs
        return OrSurface(lhs, rhs)

    def unroll(self):
        return OrSurface(self.lhs.unroll(), self.rhs.unroll())

    def split(self):
        return self.lhs.split() + self.rhs.split()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="odinson.ruleutils.queryast.OrSurface.children"><code class="name flex">
<span>def <span class="ident">children</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def children(self):
    return [self.lhs, self.rhs]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Surface.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.OrTraversal"><code class="flex name class">
<span>class <span class="ident">OrTraversal</span></span>
<span>(</span><span>lhs:<a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a>, rhs:<a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all graph traversals.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OrTraversal(Traversal):
    _COGNITIVE_WEIGHT = CognitiveWeight.OR_TRAVERSAL

    def __init__(self, lhs: Traversal, rhs: Traversal):
        self.lhs = lhs
        self.rhs = rhs

    def __str__(self):
        return f&#34;{self.lhs} | {self.rhs}&#34;

    def children(self):
        return [self.lhs, self.rhs]

    def tokens(self):
        return self.lhs.tokens() + [&#34;|&#34;] + self.rhs.tokens()

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        if self.lhs.has_holes():
            nodes = self.lhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [OrTraversal(n, self.rhs) for n in nodes]
        elif self.rhs.has_holes():
            nodes = self.rhs.expand_leftmost_hole(vocabularies, **kwargs)
            return [OrTraversal(self.lhs, n) for n in nodes]
        else:
            return []

    def permutations(self):
        return get_all_trees(self)

    def over_approximation(self):
        lhs = self.lhs.over_approximation()
        rhs = self.rhs.over_approximation()
        if lhs is None:
            return rhs
        if rhs is None:
            return lhs
        return OrTraversal(lhs, rhs)

    def under_approximation(self):
        lhs = self.lhs.under_approximation()
        rhs = self.rhs.under_approximation()
        if lhs is None:
            return rhs
        if rhs is None:
            return lhs
        return OrTraversal(lhs, rhs)

    def unroll(self):
        return OrTraversal(self.lhs.unroll(), self.rhs.unroll())

    def split(self):
        return self.lhs.split() + self.rhs.split()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="odinson.ruleutils.queryast.OrTraversal.children"><code class="name flex">
<span>def <span class="ident">children</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def children(self):
    return [self.lhs, self.rhs]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Traversal.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.OutgoingLabelTraversal"><code class="flex name class">
<span>class <span class="ident">OutgoingLabelTraversal</span></span>
<span>(</span><span>label:<a title="odinson.ruleutils.queryast.Matcher" href="#odinson.ruleutils.queryast.Matcher">Matcher</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all graph traversals.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OutgoingLabelTraversal(Traversal):
    _COGNITIVE_WEIGHT = CognitiveWeight.OUTGOING_LABEL_TRAVERSAL

    def __init__(self, label: Matcher):
        self.label = label

    def __str__(self):
        return f&#34;&gt;{self.label}&#34;

    def children(self):
        return [self.label]

    def tokens(self):
        return [&#34;&gt;&#34;] + self.label.tokens()

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        if self.label.is_hole():
            return [
                OutgoingLabelTraversal(ExactMatcher(v))
                for v in vocabularies.get(config.SYNTAX_FIELD, [])
            ]
        else:
            return []

    def over_approximation(self):
        label = self.label.over_approximation()
        if label is None:
            return None
        if isinstance(label, WildcardMatcher):
            return OutgoingWildcardTraversal()
        return OutgoingLabelTraversal(label)

    def under_approximation(self):
        label = self.label.under_approximation()
        if label is None:
            return None
        if isinstance(label, WildcardMatcher):
            return OutgoingWildcardTraversal()
        return OutgoingLabelTraversal(label)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="odinson.ruleutils.queryast.OutgoingLabelTraversal.children"><code class="name flex">
<span>def <span class="ident">children</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def children(self):
    return [self.label]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Traversal.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.OutgoingWildcardTraversal"><code class="flex name class">
<span>class <span class="ident">OutgoingWildcardTraversal</span></span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all graph traversals.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OutgoingWildcardTraversal(Traversal):
    _COGNITIVE_WEIGHT = CognitiveWeight.OUTGOING_WILDCARD_TRAVERSAL

    def __str__(self):
        return &#34;&gt;&gt;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Traversal.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.Query"><code class="flex name class">
<span>class <span class="ident">Query</span></span>
</code></dt>
<dd>
<div class="desc"><p>The base class for hybrid queries.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Query(AstNode):
    &#34;&#34;&#34;The base class for hybrid queries.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.HoleQuery" href="#odinson.ruleutils.queryast.HoleQuery">HoleQuery</a></li>
<li><a title="odinson.ruleutils.queryast.HybridQuery" href="#odinson.ruleutils.queryast.HybridQuery">HybridQuery</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.AstNode.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.RepeatSurface"><code class="flex name class">
<span>class <span class="ident">RepeatSurface</span></span>
<span>(</span><span>surf:<a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a>, min:int, max:Optional[int])</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all surface patterns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RepeatSurface(Surface):
    _COGNITIVE_WEIGHT = CognitiveWeight.REPEAT_SURFACE

    def __init__(self, surf: Surface, min: int, max: Optional[int]):
        self.surf = surf
        self.min = min
        self.max = max

    def __str__(self):
        surf = maybe_parens(self.surf, (ConcatSurface, OrSurface))
        quant = make_quantifier(self.min, self.max)
        return f&#34;{surf}{quant}&#34;

    def children(self):
        return [self.surf]

    def id_tuple(self):
        return super().id_tuple() + (self.min, self.max)

    def tokens(self):
        tokens = []
        tokens += maybe_parens_tokens(self.surf, (ConcatSurface, OrSurface))
        tokens += make_quantifier_tokens(self.min, self.max)
        return tokens

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        nodes = self.surf.expand_leftmost_hole(vocabularies, **kwargs)
        # avoid nesting repetitions
        nodes = [n for n in nodes if not isinstance(n, RepeatSurface)]
        return [RepeatSurface(n, self.min, self.max) for n in nodes]

    def permutations(self):
        return [RepeatSurface(p, self.min, self.max) for p in self.surf.permutations()]

    def over_approximation(self):
        surf = self.surf.over_approximation()
        if surf is None:
            return None
        return RepeatSurface(surf, self.min, self.max)

    def under_approximation(self):
        surf = self.surf.under_approximation()
        if surf is None:
            return None
        return RepeatSurface(surf, self.min, self.max)

    def unroll(self):
        if self.min &lt;= 1 and self.max is None:
            return ConcatSurface(self.surf, ConcatSurface(self.surf, self))
        return self

    def num_quantifiers(self):
        return 1 + self.surf.num_quantifiers()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="odinson.ruleutils.queryast.RepeatSurface.children"><code class="name flex">
<span>def <span class="ident">children</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def children(self):
    return [self.surf]</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.RepeatSurface.id_tuple"><code class="name flex">
<span>def <span class="ident">id_tuple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_tuple(self):
    return super().id_tuple() + (self.min, self.max)</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.RepeatSurface.num_quantifiers"><code class="name flex">
<span>def <span class="ident">num_quantifiers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_quantifiers(self):
    return 1 + self.surf.num_quantifiers()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Surface.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.RepeatTraversal"><code class="flex name class">
<span>class <span class="ident">RepeatTraversal</span></span>
<span>(</span><span>traversal:<a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a>, min:int, max:Optional[int])</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all graph traversals.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RepeatTraversal(Traversal):
    _COGNITIVE_WEIGHT = CognitiveWeight.REPEAT_TRAVERSAL

    def __init__(self, traversal: Traversal, min: int, max: Optional[int]):
        self.traversal = traversal
        self.min = min
        self.max = max

    def __str__(self):
        traversal = maybe_parens(self.traversal, (ConcatTraversal, OrTraversal))
        quant = make_quantifier(self.min, self.max)
        return f&#34;{traversal}{quant}&#34;

    def children(self):
        return [self.traversal]

    def id_tuple(self):
        return super().id_tuple() + (self.min, self.max)

    def tokens(self):
        tokens = []
        tokens += maybe_parens_tokens(self.traversal, (ConcatTraversal, OrTraversal))
        tokens += make_quantifier_tokens(self.min, self.max)
        return tokens

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        nodes = self.traversal.expand_leftmost_hole(vocabularies, **kwargs)
        nodes = [n for n in nodes if not isinstance(n, RepeatTraversal)]
        return [RepeatTraversal(n, self.min, self.max) for n in nodes]

    def permutations(self):
        return [
            RepeatTraversal(p, self.min, self.max)
            for p in self.traversal.permutations()
        ]

    def over_approximation(self):
        traversal = self.traversal.over_approximation()
        if traversal is None:
            return None
        return RepeatTraversal(traversal, self.min, self.max)

    def under_approximation(self):
        traversal = self.traversal.under_approximation()
        if traversal is None:
            return None
        return RepeatTraversal(traversal, self.min, self.max)

    def unroll(self):
        if self.min &lt;= 1 and self.max is None:
            return ConcatTraversal(
                self.traversal, ConcatTraversal(self.traversal, self)
            )
        return self

    def num_quantifiers(self):
        return 1 + self.traversal.num_quantifiers()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="odinson.ruleutils.queryast.RepeatTraversal.children"><code class="name flex">
<span>def <span class="ident">children</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def children(self):
    return [self.traversal]</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.RepeatTraversal.id_tuple"><code class="name flex">
<span>def <span class="ident">id_tuple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_tuple(self):
    return super().id_tuple() + (self.min, self.max)</code></pre>
</details>
</dd>
<dt id="odinson.ruleutils.queryast.RepeatTraversal.num_quantifiers"><code class="name flex">
<span>def <span class="ident">num_quantifiers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_quantifiers(self):
    return 1 + self.traversal.num_quantifiers()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Traversal.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Traversal.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.Surface"><code class="flex name class">
<span>class <span class="ident">Surface</span></span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all surface patterns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Surface(AstNode):
    &#34;&#34;&#34;The base class for all surface patterns.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.ConcatSurface" href="#odinson.ruleutils.queryast.ConcatSurface">ConcatSurface</a></li>
<li><a title="odinson.ruleutils.queryast.HoleSurface" href="#odinson.ruleutils.queryast.HoleSurface">HoleSurface</a></li>
<li><a title="odinson.ruleutils.queryast.MentionSurface" href="#odinson.ruleutils.queryast.MentionSurface">MentionSurface</a></li>
<li><a title="odinson.ruleutils.queryast.OrSurface" href="#odinson.ruleutils.queryast.OrSurface">OrSurface</a></li>
<li><a title="odinson.ruleutils.queryast.RepeatSurface" href="#odinson.ruleutils.queryast.RepeatSurface">RepeatSurface</a></li>
<li><a title="odinson.ruleutils.queryast.TokenSurface" href="#odinson.ruleutils.queryast.TokenSurface">TokenSurface</a></li>
<li><a title="odinson.ruleutils.queryast.WildcardSurface" href="#odinson.ruleutils.queryast.WildcardSurface">WildcardSurface</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.AstNode.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.TokenSurface"><code class="flex name class">
<span>class <span class="ident">TokenSurface</span></span>
<span>(</span><span>c:<a title="odinson.ruleutils.queryast.Constraint" href="#odinson.ruleutils.queryast.Constraint">Constraint</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all surface patterns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TokenSurface(Surface):
    _COGNITIVE_WEIGHT = CognitiveWeight.TOKEN_SURFACE

    def __init__(self, c: Constraint):
        self.constraint = c

    def __str__(self):
        return f&#34;[{self.constraint}]&#34;

    def children(self):
        return [self.constraint]

    def tokens(self):
        return [&#34;[&#34;, *self.constraint.tokens(), &#34;]&#34;]

    def expand_leftmost_hole(self, vocabularies, **kwargs):
        nodes = self.constraint.expand_leftmost_hole(vocabularies, **kwargs)
        return [TokenSurface(n) for n in nodes]

    def permutations(self):
        return [TokenSurface(p) for p in self.constraint.permutations()]

    def over_approximation(self):
        constraint = self.constraint.over_approximation()
        if constraint is None:
            return None
        if isinstance(constraint, WildcardConstraint):
            return WildcardSurface()
        return TokenSurface(constraint)

    def under_approximation(self):
        constraint = self.constraint.under_approximation()
        if constraint is None:
            return None
        if isinstance(constraint, WildcardConstraint):
            return WildcardSurface()
        return TokenSurface(constraint)

    def unroll(self):
        return TokenSurface(self.constraint.unroll())

    def split(self):
        return [TokenSurface(c) for c in self.constraint.split()]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="odinson.ruleutils.queryast.TokenSurface.children"><code class="name flex">
<span>def <span class="ident">children</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def children(self):
    return [self.constraint]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Surface.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.Traversal"><code class="flex name class">
<span>class <span class="ident">Traversal</span></span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all graph traversals.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Traversal(AstNode):
    &#34;&#34;&#34;The base class for all graph traversals.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.ConcatTraversal" href="#odinson.ruleutils.queryast.ConcatTraversal">ConcatTraversal</a></li>
<li><a title="odinson.ruleutils.queryast.HoleTraversal" href="#odinson.ruleutils.queryast.HoleTraversal">HoleTraversal</a></li>
<li><a title="odinson.ruleutils.queryast.IncomingLabelTraversal" href="#odinson.ruleutils.queryast.IncomingLabelTraversal">IncomingLabelTraversal</a></li>
<li><a title="odinson.ruleutils.queryast.IncomingWildcardTraversal" href="#odinson.ruleutils.queryast.IncomingWildcardTraversal">IncomingWildcardTraversal</a></li>
<li><a title="odinson.ruleutils.queryast.OrTraversal" href="#odinson.ruleutils.queryast.OrTraversal">OrTraversal</a></li>
<li><a title="odinson.ruleutils.queryast.OutgoingLabelTraversal" href="#odinson.ruleutils.queryast.OutgoingLabelTraversal">OutgoingLabelTraversal</a></li>
<li><a title="odinson.ruleutils.queryast.OutgoingWildcardTraversal" href="#odinson.ruleutils.queryast.OutgoingWildcardTraversal">OutgoingWildcardTraversal</a></li>
<li><a title="odinson.ruleutils.queryast.RepeatTraversal" href="#odinson.ruleutils.queryast.RepeatTraversal">RepeatTraversal</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.AstNode.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.WildcardConstraint"><code class="flex name class">
<span>class <span class="ident">WildcardConstraint</span></span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all token constraints.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WildcardConstraint(Constraint):
    def __str__(self):
        # this should never be rendered
        return &#34;???&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Constraint" href="#odinson.ruleutils.queryast.Constraint">Constraint</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Constraint" href="#odinson.ruleutils.queryast.Constraint">Constraint</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Constraint.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Constraint.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="odinson.ruleutils.queryast.WildcardSurface"><code class="flex name class">
<span>class <span class="ident">WildcardSurface</span></span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all surface patterns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WildcardSurface(Surface):
    _COGNITIVE_WEIGHT = CognitiveWeight.WILDCARD_SURFACE

    def __str__(self):
        return &#34;[]&#34;

    def tokens(self):
        return [&#34;[&#34;, &#34;]&#34;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a></li>
<li><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a></b></code>:
<ul class="hlist">
<li><code><a title="odinson.ruleutils.queryast.Surface.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.Surface.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="odinson.ruleutils" href="index.html">odinson.ruleutils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="odinson.ruleutils.queryast.AndConstraint" href="#odinson.ruleutils.queryast.AndConstraint">AndConstraint</a></code></h4>
<ul class="">
<li><code><a title="odinson.ruleutils.queryast.AndConstraint.children" href="#odinson.ruleutils.queryast.AndConstraint.children">children</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.AstNode" href="#odinson.ruleutils.queryast.AstNode">AstNode</a></code></h4>
<ul class="">
<li><code><a title="odinson.ruleutils.queryast.AstNode.children" href="#odinson.ruleutils.queryast.AstNode.children">children</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.cognitive_weight" href="#odinson.ruleutils.queryast.AstNode.cognitive_weight">cognitive_weight</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.effort" href="#odinson.ruleutils.queryast.AstNode.effort">effort</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.expand_leftmost_hole" href="#odinson.ruleutils.queryast.AstNode.expand_leftmost_hole">expand_leftmost_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.has_holes" href="#odinson.ruleutils.queryast.AstNode.has_holes">has_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.id_tuple" href="#odinson.ruleutils.queryast.AstNode.id_tuple">id_tuple</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.implementation_length" href="#odinson.ruleutils.queryast.AstNode.implementation_length">implementation_length</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.is_hole" href="#odinson.ruleutils.queryast.AstNode.is_hole">is_hole</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.is_valid" href="#odinson.ruleutils.queryast.AstNode.is_valid">is_valid</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.max_tree_height" href="#odinson.ruleutils.queryast.AstNode.max_tree_height">max_tree_height</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.min_tree_height" href="#odinson.ruleutils.queryast.AstNode.min_tree_height">min_tree_height</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_constraint_holes" href="#odinson.ruleutils.queryast.AstNode.num_constraint_holes">num_constraint_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_distinct_operands" href="#odinson.ruleutils.queryast.AstNode.num_distinct_operands">num_distinct_operands</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_distinct_operators" href="#odinson.ruleutils.queryast.AstNode.num_distinct_operators">num_distinct_operators</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_holes" href="#odinson.ruleutils.queryast.AstNode.num_holes">num_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_leaves" href="#odinson.ruleutils.queryast.AstNode.num_leaves">num_leaves</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_matcher_holes" href="#odinson.ruleutils.queryast.AstNode.num_matcher_holes">num_matcher_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_nodes" href="#odinson.ruleutils.queryast.AstNode.num_nodes">num_nodes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_operands" href="#odinson.ruleutils.queryast.AstNode.num_operands">num_operands</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_operators" href="#odinson.ruleutils.queryast.AstNode.num_operators">num_operators</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_quantifiers" href="#odinson.ruleutils.queryast.AstNode.num_quantifiers">num_quantifiers</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_query_holes" href="#odinson.ruleutils.queryast.AstNode.num_query_holes">num_query_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_surface_holes" href="#odinson.ruleutils.queryast.AstNode.num_surface_holes">num_surface_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.num_traversal_holes" href="#odinson.ruleutils.queryast.AstNode.num_traversal_holes">num_traversal_holes</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.number_incomings" href="#odinson.ruleutils.queryast.AstNode.number_incomings">number_incomings</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.number_outgoings" href="#odinson.ruleutils.queryast.AstNode.number_outgoings">number_outgoings</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.operands" href="#odinson.ruleutils.queryast.AstNode.operands">operands</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.operators" href="#odinson.ruleutils.queryast.AstNode.operators">operators</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.over_approximation" href="#odinson.ruleutils.queryast.AstNode.over_approximation">over_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.permutations" href="#odinson.ruleutils.queryast.AstNode.permutations">permutations</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.potential_volume" href="#odinson.ruleutils.queryast.AstNode.potential_volume">potential_volume</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.preorder_traversal" href="#odinson.ruleutils.queryast.AstNode.preorder_traversal">preorder_traversal</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.program_length" href="#odinson.ruleutils.queryast.AstNode.program_length">program_length</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.program_level" href="#odinson.ruleutils.queryast.AstNode.program_level">program_level</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.program_volume" href="#odinson.ruleutils.queryast.AstNode.program_volume">program_volume</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.proportion_incoming" href="#odinson.ruleutils.queryast.AstNode.proportion_incoming">proportion_incoming</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.redundancy_patterns" href="#odinson.ruleutils.queryast.AstNode.redundancy_patterns">redundancy_patterns</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.split" href="#odinson.ruleutils.queryast.AstNode.split">split</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.tokens" href="#odinson.ruleutils.queryast.AstNode.tokens">tokens</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.tree_height" href="#odinson.ruleutils.queryast.AstNode.tree_height">tree_height</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.under_approximation" href="#odinson.ruleutils.queryast.AstNode.under_approximation">under_approximation</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.unroll" href="#odinson.ruleutils.queryast.AstNode.unroll">unroll</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.AstNode.vocabulary_length" href="#odinson.ruleutils.queryast.AstNode.vocabulary_length">vocabulary_length</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.ConcatSurface" href="#odinson.ruleutils.queryast.ConcatSurface">ConcatSurface</a></code></h4>
<ul class="">
<li><code><a title="odinson.ruleutils.queryast.ConcatSurface.children" href="#odinson.ruleutils.queryast.ConcatSurface.children">children</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.ConcatTraversal" href="#odinson.ruleutils.queryast.ConcatTraversal">ConcatTraversal</a></code></h4>
<ul class="">
<li><code><a title="odinson.ruleutils.queryast.ConcatTraversal.children" href="#odinson.ruleutils.queryast.ConcatTraversal.children">children</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.Constraint" href="#odinson.ruleutils.queryast.Constraint">Constraint</a></code></h4>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.ExactMatcher" href="#odinson.ruleutils.queryast.ExactMatcher">ExactMatcher</a></code></h4>
<ul class="">
<li><code><a title="odinson.ruleutils.queryast.ExactMatcher.id_tuple" href="#odinson.ruleutils.queryast.ExactMatcher.id_tuple">id_tuple</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.FieldConstraint" href="#odinson.ruleutils.queryast.FieldConstraint">FieldConstraint</a></code></h4>
<ul class="">
<li><code><a title="odinson.ruleutils.queryast.FieldConstraint.children" href="#odinson.ruleutils.queryast.FieldConstraint.children">children</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.HoleConstraint" href="#odinson.ruleutils.queryast.HoleConstraint">HoleConstraint</a></code></h4>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.HoleMatcher" href="#odinson.ruleutils.queryast.HoleMatcher">HoleMatcher</a></code></h4>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.HoleQuery" href="#odinson.ruleutils.queryast.HoleQuery">HoleQuery</a></code></h4>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.HoleSurface" href="#odinson.ruleutils.queryast.HoleSurface">HoleSurface</a></code></h4>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.HoleTraversal" href="#odinson.ruleutils.queryast.HoleTraversal">HoleTraversal</a></code></h4>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.HybridQuery" href="#odinson.ruleutils.queryast.HybridQuery">HybridQuery</a></code></h4>
<ul class="">
<li><code><a title="odinson.ruleutils.queryast.HybridQuery.children" href="#odinson.ruleutils.queryast.HybridQuery.children">children</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.IncomingLabelTraversal" href="#odinson.ruleutils.queryast.IncomingLabelTraversal">IncomingLabelTraversal</a></code></h4>
<ul class="">
<li><code><a title="odinson.ruleutils.queryast.IncomingLabelTraversal.children" href="#odinson.ruleutils.queryast.IncomingLabelTraversal.children">children</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.IncomingWildcardTraversal" href="#odinson.ruleutils.queryast.IncomingWildcardTraversal">IncomingWildcardTraversal</a></code></h4>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.Matcher" href="#odinson.ruleutils.queryast.Matcher">Matcher</a></code></h4>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.MentionSurface" href="#odinson.ruleutils.queryast.MentionSurface">MentionSurface</a></code></h4>
<ul class="">
<li><code><a title="odinson.ruleutils.queryast.MentionSurface.children" href="#odinson.ruleutils.queryast.MentionSurface.children">children</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.NotConstraint" href="#odinson.ruleutils.queryast.NotConstraint">NotConstraint</a></code></h4>
<ul class="">
<li><code><a title="odinson.ruleutils.queryast.NotConstraint.children" href="#odinson.ruleutils.queryast.NotConstraint.children">children</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.OrConstraint" href="#odinson.ruleutils.queryast.OrConstraint">OrConstraint</a></code></h4>
<ul class="">
<li><code><a title="odinson.ruleutils.queryast.OrConstraint.children" href="#odinson.ruleutils.queryast.OrConstraint.children">children</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.OrSurface" href="#odinson.ruleutils.queryast.OrSurface">OrSurface</a></code></h4>
<ul class="">
<li><code><a title="odinson.ruleutils.queryast.OrSurface.children" href="#odinson.ruleutils.queryast.OrSurface.children">children</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.OrTraversal" href="#odinson.ruleutils.queryast.OrTraversal">OrTraversal</a></code></h4>
<ul class="">
<li><code><a title="odinson.ruleutils.queryast.OrTraversal.children" href="#odinson.ruleutils.queryast.OrTraversal.children">children</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.OutgoingLabelTraversal" href="#odinson.ruleutils.queryast.OutgoingLabelTraversal">OutgoingLabelTraversal</a></code></h4>
<ul class="">
<li><code><a title="odinson.ruleutils.queryast.OutgoingLabelTraversal.children" href="#odinson.ruleutils.queryast.OutgoingLabelTraversal.children">children</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.OutgoingWildcardTraversal" href="#odinson.ruleutils.queryast.OutgoingWildcardTraversal">OutgoingWildcardTraversal</a></code></h4>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.Query" href="#odinson.ruleutils.queryast.Query">Query</a></code></h4>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.RepeatSurface" href="#odinson.ruleutils.queryast.RepeatSurface">RepeatSurface</a></code></h4>
<ul class="">
<li><code><a title="odinson.ruleutils.queryast.RepeatSurface.children" href="#odinson.ruleutils.queryast.RepeatSurface.children">children</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.RepeatSurface.id_tuple" href="#odinson.ruleutils.queryast.RepeatSurface.id_tuple">id_tuple</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.RepeatSurface.num_quantifiers" href="#odinson.ruleutils.queryast.RepeatSurface.num_quantifiers">num_quantifiers</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.RepeatTraversal" href="#odinson.ruleutils.queryast.RepeatTraversal">RepeatTraversal</a></code></h4>
<ul class="">
<li><code><a title="odinson.ruleutils.queryast.RepeatTraversal.children" href="#odinson.ruleutils.queryast.RepeatTraversal.children">children</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.RepeatTraversal.id_tuple" href="#odinson.ruleutils.queryast.RepeatTraversal.id_tuple">id_tuple</a></code></li>
<li><code><a title="odinson.ruleutils.queryast.RepeatTraversal.num_quantifiers" href="#odinson.ruleutils.queryast.RepeatTraversal.num_quantifiers">num_quantifiers</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.Surface" href="#odinson.ruleutils.queryast.Surface">Surface</a></code></h4>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.TokenSurface" href="#odinson.ruleutils.queryast.TokenSurface">TokenSurface</a></code></h4>
<ul class="">
<li><code><a title="odinson.ruleutils.queryast.TokenSurface.children" href="#odinson.ruleutils.queryast.TokenSurface.children">children</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.Traversal" href="#odinson.ruleutils.queryast.Traversal">Traversal</a></code></h4>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.WildcardConstraint" href="#odinson.ruleutils.queryast.WildcardConstraint">WildcardConstraint</a></code></h4>
</li>
<li>
<h4><code><a title="odinson.ruleutils.queryast.WildcardSurface" href="#odinson.ruleutils.queryast.WildcardSurface">WildcardSurface</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>